<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>跟着做一个JSON解析器（三） | AYu</title>
  <meta name="author" content="AYu">
  
  <meta name="description" content="学习生活片段记录">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="跟着做一个JSON解析器（三）"/>
  <meta property="og:site_name" content="AYu"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.ico" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="atom.xml" title="AYu" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">AYu</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archive" title="All the articles.">
			  <i class=""></i>Archive
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> 跟着做一个JSON解析器（三）</h1>
		</div>
	


<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>跟着github上的项目json-tutorial完成一个json解析器。本文对应该项目的第三单元，重点在于解析字符串类型。<a id="more"></a></p>
<p>👉<a target="_blank" rel="noopener" href="https://github.com/miloyip/json-tutorial">原项目地址</a></p>
<h1 id="一、JSON-字符串语法"><a href="#一、JSON-字符串语法" class="headerlink" title="一、JSON 字符串语法"></a>一、JSON 字符串语法</h1><p>JSON 的字符串语法和 C 语言很相似，都是以双引号把字符括起来，如 <code>&quot;Hello&quot;</code>。但字符串采用了双引号作分隔，那么怎样可以在字符串中插入一个双引号？ 把 <code>a&quot;b</code> 写成 <code>&quot;a&quot;b&quot;</code> 肯定不行，都不知道那里是字符串的结束了。因此，我们需要引入转义字符（escape character），C 语言和 JSON 都使用 <code>\</code>（反斜线）作为转义字符，那么 <code>&quot;</code> 在字符串中就表示为 <code>\&quot;</code>，<code>a&quot;b</code> 的 JSON 字符串则写成 <code>&quot;a\&quot;b&quot;</code>。如以下的字符串语法所示，JSON 共支持 9 种转义序列：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">string</span> = quotation-mark *char quotation-mark</span><br><span class="line"><span class="attribute">char</span> = unescaped /</span><br><span class="line">   escape (</span><br><span class="line">       <span class="symbol">%x22</span> /          <span class="comment">; &quot;    quotation mark  U+0022</span></span><br><span class="line">       <span class="symbol">%x5C</span> /          <span class="comment">; \    reverse solidus U+005C</span></span><br><span class="line">       <span class="symbol">%x2F</span> /          <span class="comment">; /    solidus         U+002F</span></span><br><span class="line">       <span class="symbol">%x62</span> /          <span class="comment">; b    backspace       U+0008</span></span><br><span class="line">       <span class="symbol">%x66</span> /          <span class="comment">; f    form feed       U+000C</span></span><br><span class="line">       <span class="symbol">%x6E</span> /          <span class="comment">; n    line feed       U+000A</span></span><br><span class="line">       <span class="symbol">%x72</span> /          <span class="comment">; r    carriage return U+000D</span></span><br><span class="line">       <span class="symbol">%x74</span> /          <span class="comment">; t    tab             U+0009</span></span><br><span class="line">       <span class="symbol">%x75</span> <span class="number">4</span><span class="keyword">HEXDIG</span> )  <span class="comment">; uXXXX                U+XXXX</span></span><br><span class="line"><span class="attribute">escape</span> = <span class="symbol">%x5C</span>          <span class="comment">; \</span></span><br><span class="line"><span class="attribute">quotation-mark</span> = <span class="symbol">%x22</span>  <span class="comment">; &quot;</span></span><br><span class="line"><span class="attribute">unescaped</span> = <span class="symbol">%x20-21</span> / <span class="symbol">%x23-5B</span> / <span class="symbol">%x5D-10FFFF</span></span><br></pre></td></tr></table></figure>

<p>简单翻译一下，JSON 字符串是由前后两个双引号夹着零至多个字符。字符分为无转义字符或转义序列。转义序列有 9 种，都是以反斜线开始，如常见的 <code>\n</code> 代表换行符。比较特殊的是 <code>\uXXXX</code>，当中 XXXX 为 16 进位的 UTF-16 编码，本单元将不处理这种转义序列，留待下回分解。</p>
<p>无转义字符就是普通的字符，语法中列出了合法的码点范围（码点还是在下单元才介绍）。要注意的是，该范围不包括 <strong>0 至 31、双引号和反斜线</strong>，这些码点都必须要使用转义方式表示。</p>
<h1 id="二、字符串表示"><a href="#二、字符串表示" class="headerlink" title="二、字符串表示"></a>二、字符串表示</h1><p>在 C 语言中，字符串一般表示为空结尾字符串（null-terminated string），即以空字符（<code>&#39;\0&#39;</code>）代表字符串的结束。然而，JSON 字符串是允许含有空字符的，例如这个 JSON <code>&quot;Hello\u0000World&quot;</code> 就是单个字符串，解析后为11个字符。如果纯粹使用空结尾字符串来表示 JSON 解析后的结果，就没法处理空字符。</p>
<p>因此，我们可以分配内存来储存解析后的字符，以及记录字符的数目（即字符串长度）。<u>由于大部分 C 程序都假设字符串是空结尾字符串，我们还是在最后加上一个空字符，那么不需处理 <code>\u0000</code> 这种字符的应用可以简单地把它当作是空结尾字符串。</u></p>
<p>了解需求后，我们考虑实现。<code>lept_value</code> 事实上是一种变体类型（variant type），我们通过 <code>type</code> 来决定它现时是哪种类型，而这也决定了哪些成员是有效的。首先我们简单地在这个结构中加入两个成员：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    char* s;</span><br><span class="line">    size_t len;</span><br><span class="line">    double n;</span><br><span class="line">    lept_type type;</span><br><span class="line">&#125;lept_value;</span><br></pre></td></tr></table></figure>

<p>然而我们知道，一个值不可能同时为数字和字符串，因此我们可使用 C 语言的 <code>union</code> 来节省内存：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123; <span class="title">char</span>* <span class="title">s</span>;</span> size_t len; &#125;s;  <span class="regexp">/* string */</span></span><br><span class="line">        double n;                          <span class="regexp">/* number */</span></span><br><span class="line">    &#125;u;</span><br><span class="line">    lept_type <span class="keyword">type</span>;</span><br><span class="line">&#125;lept_value;</span><br></pre></td></tr></table></figure>

<p>这两种设计在 32 位平台时的内存布局如下，可看出右方使用 <code>union</code> 的能省下内存。</p>
<p><img src="/2021/Make-a-JSON-parser-3/union_layout.png" alt="union_layout"></p>
<p>我们要把之前的 <code>v-&gt;n</code> 改成 <code>v-&gt;u.n</code>。而要访问字符串的数据，则要使用 <code>v-&gt;u.s.s</code> 和 <code>v-&gt;u.s.len</code>。这种写法比较麻烦吧，其实 C11 新增了匿名 struct/union 语法，就可以采用 <code>v-&gt;n</code>、<code>v-&gt;s</code>、<code>v-&gt;len</code> 来作访问。</p>
<h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><p>由于字符串的长度不是固定的，我们要动态分配内存。为简单起见，我们使用标准库 <code>&lt;stdlib.h&gt;</code> 中的 <code>malloc()</code>、<code>realloc()</code> 和 <code>free()</code> 来分配／释放内存。</p>
<p>当设置一个值为字符串时，我们需要把参数中的字符串复制一份：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lept_set_string</span><span class="params">(lept_value* v, <span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    assert(v != <span class="literal">NULL</span> &amp;&amp; (s != <span class="literal">NULL</span> || len == <span class="number">0</span>));</span><br><span class="line">    lept_free(v);</span><br><span class="line">    v-&gt;u.s.s = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(v-&gt;u.s.s, s, len);</span><br><span class="line">    v-&gt;u.s.s[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    v-&gt;u.s.len = len;</span><br><span class="line">    v-&gt;type = LEPT_STRING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断言中的条件是，非空指针（有具体的字符串）或是零长度的字符串都是合法的。</p>
<p>注意，在设置这个 <code>v</code> 之前，我们需要先调用 <code>lept_free(v)</code> 去清空 <code>v</code> 可能分配到的内存。例如原来已有一字符串，我们要先把它释放。然后就是简单地用 <code>malloc()</code> 分配及用 <code>memcpy()</code> 复制，并补上结尾空字符。<code>malloc(len + 1)</code> 中的 1 是因为结尾空字符。</p>
<p>那么，再看看 <code>lept_free()</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">void</span> lept_free(lept_value* v) &#123;</span><br><span class="line">    assert(v != <span class="type">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;<span class="class"><span class="keyword">type</span> == <span class="type">LEPT_STRING</span>)</span></span><br><span class="line">        free(v-&gt;u.s.s);</span><br><span class="line">    v-&gt;<span class="class"><span class="keyword">type</span> = <span class="type">LEPT_NULL</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现时仅当值是字符串类型，我们才要处理，之后我们还要加上对数组及对象的释放。<code>lept_free(v)</code> 之后，会把它的类型变成 null。<u>这个设计能避免重复释放</u>。</p>
<p>但也由于我们会检查 <code>v</code> 的类型，在调用所有访问函数之前，我们必须初始化该类型。所以我们加入 <code>lept_init(v)</code>，因非常简单我们用宏实现：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define lept<span class="constructor">_init(<span class="params">v</span>)</span> <span class="keyword">do</span> &#123; (v)-&gt;<span class="keyword">type</span> = LEPT_NULL; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>用上 <code>do &#123; ... &#125; while(0)</code> 是为了把表达式转为语句，模仿无返回值的函数。</p>
<p>其实在前两个单元中，我们只提供读取值的 API，没有写入的 API，就是因为写入时我们还要考虑释放内存。我们在本单元中把它们补全：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lept_set_null(v) lept_free(v)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lept_get_boolean</span><span class="params">(<span class="keyword">const</span> lept_value* v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lept_set_boolean</span><span class="params">(lept_value* v, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">lept_get_number</span><span class="params">(<span class="keyword">const</span> lept_value* v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lept_set_number</span><span class="params">(lept_value* v, <span class="keyword">double</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">lept_get_string</span><span class="params">(<span class="keyword">const</span> lept_value* v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">lept_get_string_length</span><span class="params">(<span class="keyword">const</span> lept_value* v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lept_set_string</span><span class="params">(lept_value* v, <span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由于 <code>lept_free()</code> 实际上也会把 <code>v</code> 变成 null 值，我们只用一个宏来提供 <code>lept_set_null()</code> 这个 API。</p>
<p>应用方的代码在调用 <code>lept_parse()</code> 之后，最终也应该调用 <code>lept_free()</code> 去释放内存。我们把之前的单元测试也加入此调用。</p>
<p>如果不使用 <code>lept_parse()</code>，我们需要初始化值，那么就像以下的单元测试，先 <code>lept_init()</code>，最后 <code>lept_free()</code>。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void test<span class="constructor">_access_string()</span> &#123;</span><br><span class="line">    lept_value v;</span><br><span class="line">    lept<span class="constructor">_init(&amp;<span class="params">v</span>)</span>;</span><br><span class="line">    lept<span class="constructor">_set_string(&amp;<span class="params">v</span>, <span class="string">&quot;&quot;</span>, 0)</span>;</span><br><span class="line">    <span class="constructor">EXPECT_EQ_STRING(<span class="string">&quot;&quot;</span>, <span class="params">lept_get_string</span>(&amp;<span class="params">v</span>)</span>, lept<span class="constructor">_get_string_length(&amp;<span class="params">v</span>)</span>);</span><br><span class="line">    lept<span class="constructor">_set_string(&amp;<span class="params">v</span>, <span class="string">&quot;Hello&quot;</span>, 5)</span>;</span><br><span class="line">    <span class="constructor">EXPECT_EQ_STRING(<span class="string">&quot;Hello&quot;</span>, <span class="params">lept_get_string</span>(&amp;<span class="params">v</span>)</span>, lept<span class="constructor">_get_string_length(&amp;<span class="params">v</span>)</span>);</span><br><span class="line">    lept<span class="constructor">_free(&amp;<span class="params">v</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、缓冲区与堆栈"><a href="#四、缓冲区与堆栈" class="headerlink" title="四、缓冲区与堆栈"></a>四、缓冲区与堆栈</h1><p>我们解析字符串（以及之后的数组、对象）时，需要把解析的结果先储存在一个临时的缓冲区，最后再用 <code>lept_set_string()</code> 把缓冲区的结果设进值之中。（？）在完成解析一个字符串之前，这个缓冲区的大小是不能预知的。因此，我们可以采用动态数组（dynamic array）这种数据结构，即数组空间不足时，能自动扩展。C++ 标准库的 <code>std::vector</code> 也是一种动态数组。</p>
<p>如果每次解析字符串时，都重新建一个动态数组，那么是比较耗时的。我们可以重用这个动态数组，每次解析 JSON 时就只需要创建一个。而且我们将会发现，无论是解析字符串、数组或对象，我们也只需要以先进后出的方式访问这个动态数组。换句话说，我们需要一个动态的堆栈（stack）数据结构。</p>
<p>我们把一个动态堆栈的数据放进 <code>lept_context</code> 里：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* json;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">stack</span>;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>, top;</span><br><span class="line">&#125;lept_context;</span><br></pre></td></tr></table></figure>

<p>当中 <code>size</code> 是当前的堆栈容量，<code>top</code> 是栈顶的位置（由于我们会扩展 <code>stack</code>，所以不要把 <code>top</code> 用指针形式存储）。</p>
<p>然后，我们在创建 <code>lept_context</code> 的时候初始化 <code>stack</code> 并最终释放内存：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lept<span class="constructor">_parse(<span class="params">lept_value</span><span class="operator">*</span> <span class="params">v</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">json</span>)</span> &#123;</span><br><span class="line">    lept_context c;</span><br><span class="line">    <span class="built_in">int</span> ret;</span><br><span class="line">    <span class="keyword">assert</span>(v != NULL);</span><br><span class="line">    c.json = json;</span><br><span class="line">    c.stack = NULL;        <span class="comment">/* &lt;- */</span></span><br><span class="line">    c.size = c.top = <span class="number">0</span>;    <span class="comment">/* &lt;- */</span></span><br><span class="line">    lept<span class="constructor">_init(<span class="params">v</span>)</span>;</span><br><span class="line">    lept<span class="constructor">_parse_whitespace(&amp;<span class="params">c</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ret = lept<span class="constructor">_parse_value(&amp;<span class="params">c</span>, <span class="params">v</span>)</span>)<span class="operator"> == </span>LEPT_PARSE_OK) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(c.top<span class="operator"> == </span><span class="number">0</span>);    <span class="comment">/* &lt;- */</span></span><br><span class="line">    free(c.stack);         <span class="comment">/* &lt;- */</span></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在释放时，加入了断言确保所有数据都被弹出。</p>
<p>然后，我们实现堆栈的压入及弹出操作。和普通的堆栈不一样，我们这个堆栈是以字节储存的。每次可要求压入任意大小的数据，它会返回数据起始的指针（会 C++ 的同学可再参考[1]）：</p>
<p>lept_context_push: 保证栈的大小并返回栈顶位置</p>
<p>lept_context_pop: 调整top并返回pop值位置</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LEPT_PARSE_STACK_INIT_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEPT_PARSE_STACK_INIT_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">lept_context_push</span><span class="params">(lept_context* c, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* ret;</span><br><span class="line">    assert(<span class="built_in">size</span> &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;top + <span class="built_in">size</span> &gt;= c-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">            c-&gt;<span class="built_in">size</span> = LEPT_PARSE_STACK_INIT_SIZE;</span><br><span class="line">        <span class="keyword">while</span> (c-&gt;top + <span class="built_in">size</span> &gt;= c-&gt;<span class="built_in">size</span>)</span><br><span class="line">            c-&gt;<span class="built_in">size</span> += c-&gt;<span class="built_in">size</span> &gt;&gt; <span class="number">1</span>;  <span class="comment">/* c-&gt;size * 1.5 */</span></span><br><span class="line">        c-&gt;<span class="built_in">stack</span> = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(c-&gt;<span class="built_in">stack</span>, c-&gt;<span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = c-&gt;<span class="built_in">stack</span> + c-&gt;top;</span><br><span class="line">    c-&gt;top += <span class="built_in">size</span>;   <span class="comment">// 更新top</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">lept_context_pop</span><span class="params">(lept_context* c, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    assert(c-&gt;top &gt;= <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">return</span> c-&gt;<span class="built_in">stack</span> + (c-&gt;top -= <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>压入时若空间不足，便回以 1.5 倍大小扩展。为什么是 1.5 倍而不是两倍？可参考 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25079705/answer/30030883">STL 的 vector 有哪些封装上的技巧？</a> 。</p>
<p>注意到这里使用了 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/memory/realloc"><code>realloc()</code></a> 来重新分配内存，<code>c-&gt;stack</code> 在初始化时为 <code>NULL</code>，<code>realloc(NULL, size)</code> 的行为是等价于 <code>malloc(size)</code> 的，所以我们不需要为第一次分配内存作特别处理。</p>
<p>另外，我们把初始大小以宏 <code>LEPT_PARSE_STACK_INIT_SIZE</code> 的形式定义，使用 <code>#ifndef X #define X ... #endif</code> 方式的好处是，使用者可在编译选项中自行设置宏，没设置的话就用缺省值。</p>
<h1 id="五、解析字符串"><a href="#五、解析字符串" class="headerlink" title="五、解析字符串"></a>五、解析字符串</h1><p>有了以上的工具，解析字符串的任务就变得很简单。我们只需要先备份栈顶，然后把解析到的字符压栈，最后计算出长度并一次性把所有字符弹出，再设置至值里便可以。以下是部分实现，没有处理转义和一些不合法字符的校验。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTC(c, ch) do &#123; *(char*)lept_context_push(c, sizeof(char)) = (ch); &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lept_parse_string</span><span class="params">(lept_context* c, lept_value* v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> head = c-&gt;top, len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p;</span><br><span class="line">    EXPECT(c, <span class="string">&#x27;\&quot;&#x27;</span>);</span><br><span class="line">    p = c-&gt;json;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = *p++;</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\&quot;&#x27;</span>:</span><br><span class="line">                len = c-&gt;top - head;</span><br><span class="line">                lept_set_string(v, (<span class="keyword">const</span> <span class="keyword">char</span>*)lept_context_pop(c, len), len);</span><br><span class="line">                c-&gt;json = p;</span><br><span class="line">                <span class="keyword">return</span> LEPT_PARSE_OK;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">                c-&gt;top = head;</span><br><span class="line">                <span class="keyword">return</span> LEPT_PARSE_MISS_QUOTATION_MARK;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                PUTC(c, ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="六、总结与练习答案"><a href="#六、总结与练习答案" class="headerlink" title="六、总结与练习答案"></a>六、总结与练习答案</h1><p>之前的单元都是固定长度的数据类型（fixed length data type），而字符串类型是可变长度的数据类型（variable length data type），因此本单元花了较多篇幅讲述内存管理和数据结构的设计和实现。字符串的解析相对数字简单，以下的习题难度不高，同学们应该可轻松完成。</p>
<ol>
<li>编写 <code>lept_get_boolean()</code> 等访问函数的单元测试，然后实现。</li>
</ol>
<p>访问函数的实现：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lept<span class="constructor">_get_boolean(<span class="params">const</span> <span class="params">lept_value</span><span class="operator">*</span> <span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span>(v != NULL<span class="operator"> &amp;&amp; </span>(v-&gt;<span class="keyword">type</span><span class="operator"> == </span>LEPT_TRUE<span class="operator"> || </span>v-&gt;<span class="keyword">type</span><span class="operator"> == </span>LEPT_FALSE));</span><br><span class="line">    return v-&gt;<span class="keyword">type</span><span class="operator"> == </span>LEPT_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lept<span class="constructor">_set_boolean(<span class="params">lept_value</span><span class="operator">*</span> <span class="params">v</span>, <span class="params">int</span> <span class="params">b</span>)</span> &#123;</span><br><span class="line">    lept<span class="constructor">_free(<span class="params">v</span>)</span>;</span><br><span class="line">    v-&gt;<span class="keyword">type</span> = b ? LEPT_TRUE : LEPT_FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double lept<span class="constructor">_get_number(<span class="params">const</span> <span class="params">lept_value</span><span class="operator">*</span> <span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span>(v != NULL<span class="operator"> &amp;&amp; </span>v-&gt;<span class="keyword">type</span><span class="operator"> == </span>LEPT_NUMBER);</span><br><span class="line">    return v-&gt;u.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lept<span class="constructor">_set_number(<span class="params">lept_value</span><span class="operator">*</span> <span class="params">v</span>, <span class="params">double</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">    lept<span class="constructor">_free(<span class="params">v</span>)</span>;</span><br><span class="line">    v-&gt;u.n = n;</span><br><span class="line">    v-&gt;<span class="keyword">type</span> = LEPT_NUMBER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编写单元测试时，我们故意先把值设为字符串，那么做可以测试设置其他类型时，有没有调用 <code>lept_free()</code> 去释放内存。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void test<span class="constructor">_access_boolean()</span> &#123;</span><br><span class="line">    lept_value v;</span><br><span class="line">    lept<span class="constructor">_init(&amp;<span class="params">v</span>)</span>;</span><br><span class="line">    lept<span class="constructor">_set_string(&amp;<span class="params">v</span>, <span class="string">&quot;a&quot;</span>, 1)</span>;</span><br><span class="line">    lept<span class="constructor">_set_boolean(&amp;<span class="params">v</span>, 1)</span>;</span><br><span class="line">    <span class="constructor">EXPECT_TRUE(<span class="params">lept_get_boolean</span>(&amp;<span class="params">v</span>)</span>);</span><br><span class="line">    lept<span class="constructor">_set_boolean(&amp;<span class="params">v</span>, 0)</span>;</span><br><span class="line">    <span class="constructor">EXPECT_FALSE(<span class="params">lept_get_boolean</span>(&amp;<span class="params">v</span>)</span>);</span><br><span class="line">    lept<span class="constructor">_free(&amp;<span class="params">v</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void test<span class="constructor">_access_number()</span> &#123;</span><br><span class="line">    lept_value v;</span><br><span class="line">    lept<span class="constructor">_init(&amp;<span class="params">v</span>)</span>;</span><br><span class="line">    lept<span class="constructor">_set_string(&amp;<span class="params">v</span>, <span class="string">&quot;a&quot;</span>, 1)</span>;</span><br><span class="line">    lept<span class="constructor">_set_number(&amp;<span class="params">v</span>, 1234.5)</span>;</span><br><span class="line">    <span class="constructor">EXPECT_EQ_DOUBLE(1234.5, <span class="params">lept_get_number</span>(&amp;<span class="params">v</span>)</span>);</span><br><span class="line">    lept<span class="constructor">_free(&amp;<span class="params">v</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们没有调用 <code>lept_free()</code>，会发生内存泄露，如何发现这些内存泄漏呢？</p>
<blockquote>
<p>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了，在这里是因为lept_type不是LEPT_STRING了，存储的字符串地址无意义不能访问），而系统也不能再次将它分配给需要的程序。</p>
</blockquote>
<h2 id="1A-Windows-下的内存泄漏检测方法"><a href="#1A-Windows-下的内存泄漏检测方法" class="headerlink" title="1A. Windows 下的内存泄漏检测方法"></a>1A. Windows 下的内存泄漏检测方法</h2><p>在 Windows 下，可使用 Visual C++ 的 <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/x98tx3cf.aspx">C Runtime Library（CRT） 检测内存泄漏</a>。</p>
<p>首先，我们在两个 .c 文件首行插入这一段代码：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WINDOWS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRTDBG_MAP_ALLOC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>并在 <code>main()</code> 开始位置插入：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WINDOWS</span></span><br><span class="line">    <span class="variable">_CrtSetDbgFlag</span>(<span class="variable">_CRTDBG_ALLOC_MEM_DF</span> | <span class="variable">_CRTDBG_LEAK_CHECK_DF</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在 Debug 配置下按 F5 生成、开始调试程序，没有任何异样。</p>
<p>然后，我们删去 <code>lept_set_boolean()</code> 中的 <code>lept_free(v)</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void lept<span class="constructor">_set_boolean(<span class="params">lept_value</span><span class="operator">*</span> <span class="params">v</span>, <span class="params">int</span> <span class="params">b</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* lept_free(v); */</span></span><br><span class="line">    v-&gt;<span class="keyword">type</span> = b ? LEPT_TRUE : LEPT_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次按 F5 生成、开始调试程序，在输出会看到内存泄漏信息：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Detected</span> memory leaks!</span><br><span class="line"><span class="attribute">Dumping</span> objects -&gt;</span><br><span class="line"><span class="attribute">C</span>:\GitHub\json-tutorial\tutorial<span class="number">03</span>_answer\leptjson.c(<span class="number">212</span>) : &#123;<span class="number">79</span>&#125; normal block at <span class="number">0</span>x<span class="number">013</span>D<span class="number">9868</span>, <span class="number">2</span> bytes long.</span><br><span class="line"> <span class="attribute">Data</span>: &lt;a &gt; <span class="number">61</span> <span class="number">00</span> </span><br><span class="line"><span class="attribute">Object</span> dump complete.</span><br></pre></td></tr></table></figure>

<p>这正是我们在单元测试中，先设置字符串，然后设布尔值时没释放字符串所分配的内存。比较麻烦的是，它没有显示调用堆栈。从输出信息中 <code>... &#123;79&#125; ...</code> 我们知道是第 79 次分配的内存做成问题，我们可以加上 <code>_CrtSetBreakAlloc(79);</code> 来调试，那么它便会在第 79 次时中断于分配调用的位置，那时候就能从调用堆栈去找出来龙去脉。</p>
<h2 id="1B-Linux-OSX-下的内存泄漏检测方法"><a href="#1B-Linux-OSX-下的内存泄漏检测方法" class="headerlink" title="1B. Linux/OSX 下的内存泄漏检测方法"></a>1B. Linux/OSX 下的内存泄漏检测方法</h2><p>在 Linux、OS X 下，我们可以使用 <a target="_blank" rel="noopener" href="https://valgrind.org/">valgrind</a> 工具（用 <code>apt-get install valgrind</code>、 <code>brew install valgrind</code>）。我们完全不用修改代码，只要在命令行执行：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">valgrind</span> <span class="string">--leak-check=full</span>  <span class="string">./leptjson_test</span></span><br><span class="line"><span class="string">==22078==</span> <span class="string">Memcheck,</span> <span class="string">a</span> <span class="string">memory</span> <span class="string">error</span> <span class="string">detector</span></span><br><span class="line"><span class="string">==22078==</span> <span class="string">Copyright</span> <span class="string">(C)</span> <span class="number">2002</span><span class="number">-2015</span><span class="string">,</span> <span class="string">and</span> <span class="string">GNU</span> <span class="string">GPL&#x27;d,</span> <span class="string">by</span> <span class="string">Julian</span> <span class="string">Seward</span> <span class="string">et</span> <span class="string">al.</span></span><br><span class="line"><span class="string">==22078==</span> <span class="string">Using</span> <span class="string">Valgrind-3.11.0</span> <span class="string">and</span> <span class="string">LibVEX;</span> <span class="string">rerun</span> <span class="string">with</span> <span class="string">-h</span> <span class="string">for</span> <span class="string">copyright</span> <span class="string">info</span></span><br><span class="line"><span class="string">==22078==</span> <span class="attr">Command:</span> <span class="string">./leptjson_test</span></span><br><span class="line"><span class="string">==22078==</span> </span><br><span class="line"><span class="string">--22078--</span> <span class="attr">run:</span> <span class="string">/usr/bin/dsymutil</span> <span class="string">&quot;./leptjson_test&quot;</span></span><br><span class="line"><span class="number">160</span><span class="string">/160</span> <span class="string">(100.00%)</span> <span class="string">passed</span></span><br><span class="line"><span class="string">==22078==</span> </span><br><span class="line"><span class="string">==22078==</span> <span class="attr">HEAP SUMMARY:</span></span><br><span class="line"><span class="string">==22078==</span>     <span class="attr">in use at exit:</span> <span class="number">27</span><span class="string">,728</span> <span class="string">bytes</span> <span class="string">in</span> <span class="number">209</span> <span class="string">blocks</span></span><br><span class="line"><span class="string">==22078==</span>   <span class="attr">total heap usage:</span> <span class="number">301</span> <span class="string">allocs,</span> <span class="number">92</span> <span class="string">frees,</span> <span class="number">34</span><span class="string">,966</span> <span class="string">bytes</span> <span class="string">allocated</span></span><br><span class="line"><span class="string">==22078==</span> </span><br><span class="line"><span class="string">==22078==</span> <span class="number">2</span> <span class="string">bytes</span> <span class="string">in</span> <span class="number">1</span> <span class="string">blocks</span> <span class="string">are</span> <span class="string">definitely</span> <span class="string">lost</span> <span class="string">in</span> <span class="string">loss</span> <span class="string">record</span> <span class="number">1</span> <span class="string">of</span> <span class="number">79</span></span><br><span class="line"><span class="string">==22078==</span>    <span class="attr">at 0x100012EBB:</span> <span class="string">malloc</span> <span class="string">(in</span> <span class="string">/usr/local/Cellar/valgrind/3.11.0/lib/valgrind/vgpreload_memcheck-amd64-darwin.so)</span></span><br><span class="line"><span class="string">==22078==</span>    <span class="attr">by 0x100008F36:</span> <span class="string">lept_set_string</span> <span class="string">(leptjson.c:208)</span></span><br><span class="line"><span class="string">==22078==</span>    <span class="attr">by 0x100008415:</span> <span class="string">test_access_boolean</span> <span class="string">(test.c:187)</span></span><br><span class="line"><span class="string">==22078==</span>    <span class="attr">by 0x100001849:</span> <span class="string">test_parse</span> <span class="string">(test.c:229)</span></span><br><span class="line"><span class="string">==22078==</span>    <span class="attr">by 0x1000017A3:</span> <span class="string">main</span> <span class="string">(test.c:235)</span></span><br><span class="line"><span class="string">==22078==</span> </span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>它发现了在 <code>test_access_boolean()</code> 中，由 <code>lept_set_string()</code> 分配的 2 个字节（<code>&quot;a&quot;</code>）泄漏了。</p>
<p>Valgrind 还有很多功能，例如可以发现未初始化变量。我们若在应用程序或测试程序中，忘了调用 <code>lept_init(&amp;v)</code>，那么 <code>v.type</code> 的值没被初始化，其值是不确定的（indeterministic），一些函数如果读取那个值就会出现问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_access_boolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lept_value v;</span><br><span class="line">    <span class="comment">/* lept_init(&amp;v); */</span></span><br><span class="line">    lept_set_string(&amp;v, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种错误有时候测试时能正确运行（刚好 <code>v.type</code> 被设为 <code>0</code>），使我们误以为程序正确，而在发布后一些机器上却可能崩溃。这种误以为正确的假像是很危险的，我们可利用 valgrind 能自动测出来：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=full  ./leptjson_test</span><br><span class="line">...</span><br><span class="line">==<span class="number">22174</span>== Conditional jump <span class="keyword">or</span> move depends on uninitialised value(s)</span><br><span class="line">==<span class="number">22174</span>==    at <span class="number">0x100008B5D</span>: lept_free (leptjson.c:<span class="number">164</span>)</span><br><span class="line">==<span class="number">22174</span>==    by <span class="number">0x100008F26</span>: lept_set_string (leptjson.c:<span class="number">207</span>)</span><br><span class="line">==<span class="number">22174</span>==    by <span class="number">0x1000083FE</span>: test_access_boolean (test.c:<span class="number">187</span>)</span><br><span class="line">==<span class="number">22174</span>==    by <span class="number">0x100001839</span>: test_parse (test.c:<span class="number">229</span>)</span><br><span class="line">==<span class="number">22174</span>==    by <span class="number">0x100001793</span>: main (test.c:<span class="number">235</span>)</span><br><span class="line">==<span class="number">22174</span>== </span><br></pre></td></tr></table></figure>

<p>它发现 <code>lept_free()</code> 中依靠了一个未初始化的值来跳转，就是 <code>v.type</code>，而错误是沿自 <code>test_access_boolean()</code>。</p>
<p>编写单元测试时，应考虑哪些执行次序会有机会出错，例如内存相关的错误。然后我们可以利用 TDD 的步骤，先令测试失败（以内存工具检测），修正代码，再确认测试是否成功。</p>
<ol start="2">
<li>实现除了 <code>\u</code> 以外的转义序列解析，令 <code>test_parse_string()</code> 中所有测试通过。</li>
</ol>
<p>转义序列的解析很直观，对其他不合法的字符返回 <code>LEPT_PARSE_INVALID_STRING_ESCAPE</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lept_parse_string</span><span class="params">(lept_context* c, lept_value* v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = *p++;</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:    <span class="comment">// 前面还有一个\是为了符合C语言的语法</span></span><br><span class="line">                <span class="keyword">switch</span> (*p++) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\&quot;&#x27;</span>: PUTC(c, <span class="string">&#x27;\&quot;&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>: PUTC(c, <span class="string">&#x27;\\&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:  PUTC(c, <span class="string">&#x27;/&#x27;</span> ); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:  PUTC(c, <span class="string">&#x27;\b&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:  PUTC(c, <span class="string">&#x27;\f&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:  PUTC(c, <span class="string">&#x27;\n&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:  PUTC(c, <span class="string">&#x27;\r&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:  PUTC(c, <span class="string">&#x27;\t&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        c-&gt;top = head;</span><br><span class="line">                        <span class="keyword">return</span> LEPT_PARSE_INVALID_STRING_ESCAPE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">/* ... */</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>解决 <code>test_parse_invalid_string_escape()</code> 和 <code>test_parse_invalid_string_char()</code> 中的失败测试。</li>
</ol>
<p>上面已解决不合法转义，余下部分的唯一难度，是要从语法中知道哪些是不合法字符：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unescaped</span> = %x<span class="number">20</span>-<span class="number">21</span> / %x<span class="number">23</span>-<span class="number">5</span>B / %x<span class="number">5</span>D-<span class="number">10</span>FFFF</span><br></pre></td></tr></table></figure>

<p>当中空缺的 %x22 是双引号，%x5C 是反斜线，都已经处理。所以不合法的字符是 %x00 至 %x1F。我们简单地在 default 里处理：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)ch &lt; <span class="number">0x20</span>) &#123; </span><br><span class="line">            c-&gt;top = head;</span><br><span class="line">            <span class="keyword">return</span> LEPT_PARSE_INVALID_STRING_CHAR;</span><br><span class="line">        &#125;</span><br><span class="line">        PUTC(c, ch);</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>注意到 <code>char</code> 带不带符号，是实现定义的。如果编译器定义 <code>char</code> 为带符号的话，<code>(unsigned char)ch &gt;= 0x80</code> 的字符，都会变成负数，并产生 <code>LEPT_PARSE_INVALID_STRING_CHAR</code> 错误。（？）我们现时还没有测试 ASCII 以外的字符，所以有没有转型至不带符号都不影响，但下一单元开始处理 Unicode 的时候就要考虑了。</p>
<ol start="4">
<li>思考如何优化 <code>test_parse_string()</code> 的性能，那些优化方法有没有缺点。（？）</li>
</ol>
<ul>
<li><p>如果整个字符串都没有转义符，我们不就是把字符复制了两次？第一次是从 <code>json</code> 到 <code>stack</code>，第二次是从 <code>stack</code> 到 <code>v-&gt;u.s.s</code>。我们可以在 <code>json</code> 扫描 <code>&#39;\0&#39;</code>、<code>&#39;\&quot;&#39;</code> 和 <code>&#39;\\&#39;</code> 3 个字符（ <code>ch &lt; 0x20</code> 还是要检查），直至它们其中一个出现，才开始用现在的解析方法。这样做的话，前半没转义的部分可以只复制一次。缺点是，代码变得复杂一些，我们也不能使用 <code>lept_set_string()</code>。</p>
</li>
<li><p>对于扫描没转义部分，我们可考虑用 SIMD 加速，如 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20037058">RapidJSON 代码剖析（二）：使用 SSE4.2 优化字符串扫描</a> 的做法。这类底层优化的缺点是不跨平台，需要设置编译选项等。</p>
</li>
<li><p>在 gcc/clang 上使用 <code>__builtin_expect()</code> 指令来处理低概率事件，例如需要对每个字符做 <code>LEPT_PARSE_INVALID_STRING_CHAR</code> 检测，我们可以假设出现不合法字符是低概率事件，然后用这个指令告之编译器，那么编译器可能可生成较快的代码。然而，这类做法明显是不跨编译器，甚至是某个版本后的 gcc 才支持。</p>
</li>
<li><p>……</p>
</li>
</ul>
<h1 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h1><p>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20029820">RapidJSON 代码剖析（一）：混合任意类型的堆栈</a></p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2021/Make-a-JSON-parser-4/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2021/null/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	<!-- 
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>
 -->


    <section id="comment">
        <h2 class="title">
            留言
        </h2>
        <div id="vcomments"></div>
        <script>
            new Valine({
                el: '#vcomments',
                appId: '8FWjWdEoyYxwoFgc2ET6DcSh-gzGzoHsz',
                appKey: 'DqH3LDGq73YqdepEDCcPgWhl',
                visitor: true,
                // avatar: 'hide',
                avatar: 'retro',
                // 这里设置CDN, 默认微博表情CDN
                // emojiCDN: 'https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/',
                // // 表情title和图片映射
                // emojiMaps: {
                //     "smile": "e3/2018new_weixioa02_org.png",
                //     "lovely": "09/2018new_keai_org.png",
                //     // ... 更多表情
                // }
            })
        </script>
    </section>


    <style type="text/css">
        h2.title {
            font-size: 25px;
            margin-bottom: 27px;
        }

        .v[data-class=v] .vwrap {
            border: 3px solid #f0f0f0;
        }
    
        .v[data-class=v] .vwrap .vheader .vinput {
            border-bottom: 1.8px dashed #f5f5f5;
            color: #bebaba;
            font-size: 17px;
        }

        .v[data-class=v] .veditor {
            font-size: 1.2em;
            color: #b5b5b5;
        }

        .v[data-class=v] .vrow .vcol {
            
            font-size: 17px;
        }

        .v[data-class=v] .vicon {
            fill: #bebebe;
        }

        .v[data-class=v] .vrow {
            font-size: 0;
            padding: 10px 0 0;
        }

        .v[data-class=v] .vbtn {
            color: #d0cdcd;
        }
        
        .v[data-class=v] .vsys {
            padding: 0em 0em;
        }

        .v[data-class=v] .vcards .vcard {
            padding-top: 0em;
        }

        .v[data-class=v] p {
            margin-bottom: 0;
            color: #c0c0c0;
        }

        a:hover {
            font-weight: 800 !important;
        }

        .v[data-class=v] a:hover{
            color: #c66400;
            background: bottom !important;
        }

        .v[data-class=v] a.vnick:hover{
            color: #c66400 !important;
            background: bottom !important;
        }

        .v[data-class=v] .vwrap .vheader .vinput:focus {
            border-bottom-color: #ff7c29;
        }

    </style>





	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2021-08-04 
	</div>
	
	<span id="busuanzi_container_page_pv">
		<i class="fa fa-eye"></i>
  		<span id="busuanzi_value_page_pv"></span>
    </span>

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/项目/">项目<span>10</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/json/">json<span>8</span></a></li>
  
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E4%B8%80%E3%80%81JSON-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%AD%E6%B3%95"><span class="toc-article-text">一、JSON 字符串语法</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA"><span class="toc-article-text">二、字符串表示</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-article-text">三、内存管理</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E5%9B%9B%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E5%A0%86%E6%A0%88"><span class="toc-article-text">四、缓冲区与堆栈</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E4%BA%94%E3%80%81%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-article-text">五、解析字符串</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0%E7%AD%94%E6%A1%88"><span class="toc-article-text">六、总结与练习答案</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#1A-Windows-%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-article-text">1A. Windows 下的内存泄漏检测方法</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#1B-Linux-OSX-%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-article-text">1B. Linux&#x2F;OSX 下的内存泄漏检测方法</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E4%B8%83%E3%80%81%E5%8F%82%E8%80%83"><span class="toc-article-text">七、参考</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2022 AYu
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br>     
     <span id="busuanzi_container_site_pv">
    	👀: <span id="busuanzi_value_site_pv"></span>    |   🙋: <span id="busuanzi_value_site_uv"></span>
	</span>
</p>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
