<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Linux-0.11操作系统实验 | AYu ☀</title>
  <meta name="author" content="AYu">
  
  <meta name="description" content="学习生活片段记录">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Linux-0.11操作系统实验"/>
  <meta property="og:site_name" content="AYu ☀"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="atom.xml" title="AYu ☀" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">AYu ☀</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archive" title="All the articles.">
			  <i class=""></i>Archive
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Linux-0.11操作系统实验</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>哈工大操作系统课程实验记录。<a id="more"></a></p>
<p>主要内容为</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">实验项目</th>
<th align="center">实验内容</th>
<th align="center">实验目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实验一</td>
<td align="center">系统引导</td>
<td align="center">编写bootsect.s和setup.s，实现一个简单的系统引导。</td>
<td align="center">深入认识系统引导过程，掌握操作系统开发基本过程。</td>
</tr>
<tr>
<td align="center">实验二</td>
<td align="center">系统调用</td>
<td align="center">添加一个系统调用whoami。</td>
<td align="center">深入认识操作系统接口的工作原理。</td>
</tr>
<tr>
<td align="center">实验三</td>
<td align="center">进程运行轨迹的跟踪</td>
<td align="center">编写程序跟踪进程的运行轨迹，主要是进程的状态切换过程。同时替换现有的Linux 0.11进程调度算法，并和现有的进程调度进行对比。</td>
<td align="center">深入认识进程，能通过实际试验来评价操作系统性能。</td>
</tr>
<tr>
<td align="center">实验四</td>
<td align="center">信号量实现和应用</td>
<td align="center">在Linux 0.11上实现信号量，并实践Multiprogramming。</td>
<td align="center">体会并发进程，掌握进程同步(互斥)技术的实现</td>
</tr>
<tr>
<td align="center">实验五</td>
<td align="center">Linux 0.11地址映射跟踪与共享</td>
<td align="center">打印Linux 0.11的地址映射过程到log文件中。</td>
<td align="center">实践逻辑地址、线性地址、物理地址、段页表等概念。</td>
</tr>
<tr>
<td align="center">实验六</td>
<td align="center">控制终端显示</td>
<td align="center">特殊按键修改系统状态，并控制显示(如按F1后总显示**)。</td>
<td align="center">深入认识设备管理，掌握终端设备驱动的实现。</td>
</tr>
<tr>
<td align="center">实验七</td>
<td align="center">proc文件系统的实现</td>
<td align="center">在Linux 0.11上实现一个proc文件系统，动态察看内核。</td>
<td align="center">体会虚拟文件系统概念，掌握文件系统的实现过程。</td>
</tr>
<tr>
<td align="center">实验八</td>
<td align="center">在Linux 0.11上实现交换分区和全局页面置换</td>
<td align="center">在Linux 0.11上完整的虚拟内存，主要是实现全局的页面置换和交换分区设备的管理，并将这两个模块放入系统。</td>
<td align="center">相比前面的实验而言，本实验较难。将全面加深进程、虚存、磁盘、中断的认识，对OS的系统性获得直接经验。</td>
</tr>
</tbody></table>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>课程提供线上环境 <a target="_blank" rel="noopener" href="https://www.lanqiao.cn/courses/115">蓝桥-操作系统原理与实践</a>。因为操作过程中出现了一些问题，我改用云服务器。</p>
<ul>
<li>Ubuntu 18.04</li>
<li>Bochs</li>
<li>gcc-3.4 (参考资料第一个github中可下载)</li>
<li>vim</li>
<li>hit-oslab-linux.tar.gz (参考资料第一个github中可下载)</li>
</ul>
<p>实验的基本流程是根据实验要求编写应用程序、修改 Linux 0.11 的源代码，用 gcc 编译后，在 Bochs 的虚拟环境中运行、调试目标代码。</p>
<blockquote>
<p>Bochs 是一个免费且开放源代码的 IA-32（x86）架构 PC 机模拟器。在它模拟出的环境中可以运行 Linux、DOS 和各种版本的 Windows 等多种操作系统。且Bochs 本身具有很高的移植性，可以运行在多种软硬件平台之上。</p>
</blockquote>
<p>hit-oslab-linux.tar.gz 解压后有：</p>
<p><img src="/2021/linux0.11-hitlabs/1.png" alt="hit-oslab-linux.tar.gz解压后内容"></p>
<ul>
<li>bochs 目录</li>
</ul>
<p>bochs 目录下是与 bochs 相关的执行文件、数据文件和配置文件。</p>
<ul>
<li>run 脚本</li>
</ul>
<p>run 是运行 bochs 的脚本命令。</p>
<p>运行后 bochs 会自动在它的虚拟软驱 A 和虚拟硬盘上各挂载一个镜像文件，软驱上挂载是 linux-0.11/Image，硬盘上挂载的是 hdc-0.11.img。</p>
<p>因为 bochs 配置文件中的设置是从软驱 A 启动，所以 Linux 0.11 会被自动加载。而 Linux 0.11 会驱动硬盘，并 mount 硬盘上的文件系统，也就是将 hdc-0.11.img 内镜像的文件系统挂载到 0.11 系统内的根目录 —— <code>/</code>。在 0.11 下访问文件系统，访问的就是 hdc-0.11.img 文件内虚拟的文件系统。</p>
<ul>
<li>hdc-0.11.img 文件</li>
</ul>
<p>hdc-0.11.img 文件的格式是 Minix 文件系统的镜像。</p>
<p>Linux 所有版本都支持这种格式的文件系统，所以可以直接在宿主 Linux 上通过 mount 命令访问此文件内的文件，达到宿主系统和 bochs 内运行的 Linux 0.11 之间交换文件的效果。</p>
<p>Windows 下目前没有（或者是还没发现）直接访问 Minix 文件系统的办法，所以要借助于 fdb.img，这是一个 1.44M 软盘的镜像文件，内部是 FAT12 文件系统。将它挂载到 bochs 的软驱 B，就可以在 0.11 中访问它。而通过 filedisk 或者 WinImage，可以在 Windows 下访问它内部的文件。</p>
<p>hdc-0.11.img 内包含有：</p>
<ul>
<li>Bash shell；</li>
<li>一些基本的 Linux 命令、工具，比如 cp、rm、mv、tar；</li>
<li>vi 编辑器；</li>
<li>gcc 1.4 编译器，可用来编译标准 C 程序；</li>
<li>as86 和 ld86；</li>
<li>Linux 0.11 的源代码，可在 0.11 下编译，然后覆盖现有的二进制内核。</li>
</ul>
<p>除此之外，还需要安装 gcc-3.4。因为Linux-0.11不能在gcc 4.x版本编译，所以要装老一点儿的编译器。</p>
<p>在Ubuntu 9.04(jaunty)及之前，用下面命令安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gcc-3.4</span></span><br></pre></td></tr></table></figure>

<p>在Ubuntu 9.10(karmic)及之后:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -zxvf gcc-3.4-ubuntu.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> gcc-3.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./inst.sh XXX  <span class="comment"># i386 or amd64</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>解压gcc-3.4时出现错误：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip: stdin: unexpected end of file</span><br><span class="line">tar: Unexpected EOF <span class="keyword">in</span> archive</span><br><span class="line">tar: Unexpected EOF <span class="keyword">in</span> archive</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<ol>
<li>下载失败，丢失内容：重新下载解压。<br>the error you’re getting is usually due to an incomplete download. The archive ends before the expected footer of the gzipped file. It will probably work fine if you just download it again.</li>
<li>在windows下解压好后再拖进Ubuntu。</li>
<li>tar.gz 文件名是否含有非法字符。</li>
</ol>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p>课程资料 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av51437944">操作系统-哈工大李治军老师</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/hoverwinter/HIT-OSLab">github实验代码</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://hoverwinter.gitbooks.io/hit-oslab-manual/content/">哈工大操作系统实验手册</a> (FAQ)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43166958/article/details/104223425">徐步小兵的实验总结</a></p>
</li>
<li><p>linux-0.11 内核完全注释 v3.0 / linux-0.12 by 赵炯</p>
</li>
</ul>
<p>注：实验中用标记为</p>
<blockquote>
</blockquote>
<p>为过程中可能出现的问题。</p>
<h1 id="熟悉实验环境"><a href="#熟悉实验环境" class="headerlink" title="熟悉实验环境"></a>熟悉实验环境</h1><h2 id="1-编译内核"><a href="#1-编译内核" class="headerlink" title="1. 编译内核"></a>1. 编译内核</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ./oslab/linux-0.11/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br></pre></td></tr></table></figure>

<p>只要最后没有出现error就说明编译成功。</p>
<p>linux-0.11目录下是全部的源代码，实验内容靠修改这些代码来完成。修改后需要重新编译内核，还是执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br></pre></td></tr></table></figure>

<p>如果重新编译后，你的修改貌似没有生效，可以试试先“make clean”，再“make all”。“make clean”是删除上一次编译生成的所有中间文件和目标文件，确保是在全新的状态下编译整个工程。</p>
<h2 id="2-运行与调试"><a href="#2-运行与调试" class="headerlink" title="2. 运行与调试"></a>2. 运行与调试</h2><p>在Bochs中运行最新编译好的内核很简单，在oslab目录下执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./run</span></span><br></pre></td></tr></table></figure>

<p>如果出现Bochs的窗口，里面显示linux的引导过程，最后停止在<code>[/usr/root/]#</code>，表示运行成功。</p>
<p><img src="/2021/linux0.11-hitlabs/2.png" alt="Bochs"></p>
<blockquote>
<p>执行时出现错误：</p>
<p>./bochs/bochs-gdb: error while loading shared libraries: libSM.so.6: cannot open shared object file: No such file or directory</p>
<p>解决方案：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40758751/article/details/88707214">https://blog.csdn.net/qq_40758751/article/details/88707214</a></p>
</blockquote>
<p>内核调试分为两种模式：汇编级调试和 C 语言级调试。</p>
<h4 id="（1）汇编级调试"><a href="#（1）汇编级调试" class="headerlink" title="（1）汇编级调试"></a>（1）汇编级调试</h4><p>汇编级调试需要执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确认在 oslab 目录下</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/oslab/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行脚本前确定已经关闭刚刚运行的 Bochs</span></span><br><span class="line">$ ./dbg-asm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>汇编级调试的启动之后 Bochs 是黑屏，这是正常的。</p>
</blockquote>
<p>可以用命令 <code>help</code> 来查看调试系统用的基本命令。更详细的信息请查阅 Bochs 使用手册。</p>
<p><img src="https://doc.shiyanlou.com/courses/uid977658-20190618-1560852351872" alt="图片描述"></p>
<h4 id="（2）C-语言级调试"><a href="#（2）C-语言级调试" class="headerlink" title="（2）C 语言级调试"></a>（2）C 语言级调试</h4><p>C 语言级调试稍微复杂一些。首先执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/oslab</span><br><span class="line">$ ./dbg-c</span><br></pre></td></tr></table></figure>

<p><strong>然后再打开一个终端窗口</strong>，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/oslab</span><br><span class="line">$ ./rungdb</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：启动的顺序不能交换，否则 gdb 无法连接。</p>
</blockquote>
<p>出现下图所示的提示，才说明连接成功：</p>
<p><img src="https://doc.shiyanlou.com/courses/uid977658-20190618-1560853330438" alt="图片描述"></p>
<p>新终端窗口中运行的是 GDB 调试器。关于 gdb 调试器请查阅 GDB 使用手册。</p>
<h2 id="3-文件交换"><a href="#3-文件交换" class="headerlink" title="3. 文件交换"></a>3. 文件交换</h2><blockquote>
<p>开始设置文件交换之前，务必关闭所有的 Bochs 进程。</p>
</blockquote>
<p>oslab 下的 <code>hdc-0.11-new.img</code> 是 0.11 内核启动后的根文件系统镜像文件，相当于在 bochs 虚拟机里装载的硬盘。在 Ubuntu 上访问其内容的方法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/oslab/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动挂载脚本</span></span><br><span class="line">$ sudo ./mount-hdc</span><br></pre></td></tr></table></figure>

<p>之后，hdc 目录下就是和 0.11 内核一模一样的文件系统了，可以读写任何文件（可能有些文件要用 sudo 才能访问）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入挂载到 Ubuntu 上的目录</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/oslab/hdc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内容</span></span><br><span class="line">$ ls -al</span><br></pre></td></tr></table></figure>

<p>读写完毕，不要忘了卸载这个文件系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/oslab/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">$ sudo umount hdc</span><br></pre></td></tr></table></figure>

<p>经过 <code>sudo ./mount-hdc</code> 这样处理以后，我们可以在 Ubuntu 的 hdc 目录下创建一个 xxx.c 文件，然后利用 Ubuntu 上的编辑工具（如 gedit 等）实现对 xxx.c 文件的编辑工作，在编辑保存以后。</p>
<p>执行 <code>sudo umount hdc</code> 后，再进入 Linux 0.11（即 run 启动 bochs 以后）就会看到这个 xxx.c（即如下图所示），这样就避免了在 Linux 0.11 上进行编辑 xxx.c 的麻烦，因为 Linux 0.11 作为一个很小的操作系统，其上的编辑工具只有 vi，使用起来非常不便。</p>
<p><img src="https://doc.shiyanlou.com/userid19614labid568time1423993300541" alt="用 Ubuntu 和 Linux 0.11 完成文件交换以后再启动 Linux 0.11 以后"></p>
<p>另外在 Linux 0.11 上产生的文件，如后面实验中产生的 <code>process.log</code> 文件，可以按这种方式 “放到” Ubuntu 下用 python 程序进行处理，当然这个 python 程序在 Linux 0.11 上显然是不好使的，因为 Linux 0.11 上搭建不了 python 解释环境。</p>
<blockquote>
<p>注意 1：不要在 0.11 内核运行的时候 mount 镜像文件，否则可能会损坏文件系统。同理，也不要在已经 mount 的时候运行 0.11 内核。</p>
<p>注意 2：在关闭 Bochs 之前，需要先在 0.11 的命令行运行 “sync”，确保所有缓存数据都存盘后，再关闭 Bochs。</p>
</blockquote>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q: 为何有时Bochs的光标闪动，却不响应我的输入？</p>
<p>A: 按一下Alt，然后再试试。 如果你习惯用Alt+Tab切换窗口，就肯定会遇到这个问题。原因是在Bochs窗口按下Alt，Bochs会接收到Alt按下的事件，然后将此事件传给Linux 0.11。待再按下Tab时，主机操作系统经判断认定这是一个切换窗口的快捷键，于是直接切换窗口，Tab和Alt抬起的事件都不会再发给Bochs。等切换会Bochs，Linux 0.11此时还处于认为Alt已按下的状态，再按任何按键都被解释成是和Alt组合的按键，所以就“好像”不响应了（按数字键可以看到它的响应）。</p>
<p>Q: 怎样加快make clean、make all的速度？</p>
<p>A: 如果只修改了kernel目录下的文件，删除kernel目录下的kernel.o，然后直接make就行了。其它目录方法类似。</p>
<p>Q: Bochs屏幕乱了怎么办？</p>
<p>A: 这是Linux的终端控制和Bochs虚拟的终端之间配合不好导致的，一般在大量输出信息后，会出现混乱，甚至很像死机。此时按ctrl+l可以缓解一下。最好是用输出重定向功能将输出都重定向到一个文件，然后用vi看。</p>
<h1 id="实验一、操作系统引导"><a href="#实验一、操作系统引导" class="headerlink" title="实验一、操作系统引导"></a>实验一、操作系统引导</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><ol>
<li>阅读《Linux内核完全注释》的第6章，对计算机和Linux 0.11的引导过程进行初步的了解；</li>
<li>按照要求改写0.11的引导程序bootsect.s<ol>
<li>bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”，其中 XXX 是你给自己的操作系统起的名字，例如 LZJos、Sunix 等（可以上论坛上秀秀谁的 OS 名字最帅，也可以显示一个特色 logo，以表示自己操作系统的与众不同。）</li>
</ol>
</li>
<li>改写进入保护模式前的设置程序setup.s。<ol>
<li>bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行”Now we are in SETUP”。</li>
<li>setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</li>
<li>setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。</li>
</ol>
</li>
<li>配套李老师课程：L2 L3</li>
</ol>
<p>开始实验前，需要了解：</p>
<p>（1）相关代码文件</p>
<p>Linux 0.11 文件夹中的 <code>boot/bootsect.s</code>、<code>boot/setup.s</code> 和 <code>tools/build.c</code> 是本实验会涉及到的源文件。它们的功能详见《注释》的 6.2、6.3 节和 16 章。</p>
<p>（2）引导程序的运行环境</p>
<p>引导程序由 BIOS 加载并运行。它活动时，操作系统还不存在，整台计算机的所有资源都由它掌控，而能利用的功能只有 BIOS 中断调用。</p>
<p>实验中主要使用 BIOS 0x10 和 0x13 中断。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>有时，继承传统意味着别手蹩脚。x86 计算机为了向下兼容，导致启动过程比较复杂。请找出 x86 计算机启动过程中，被硬件强制，软件必须遵守的两个“多此一举”的步骤（多找几个也无妨），说说它们为什么多此一举，并设计更简洁的替代方案。</p>
<p><a target="_blank" rel="noopener" href="https://www.wikiwand.com/zh/X86">wiki: x86</a></p>
<p>x86最先由实模式慢慢发展到保护模式，这中间有过很多为了向下兼容而不得不妥协的作法，比如说为了能访问更多的内存而开启了A20，为了在保护模式下可以运行实模式的程序而设计了v86(虚拟实模式) <a target="_blank" rel="noopener" href="https://www.wikiwand.com/zh/%E8%99%9A%E6%8B%9F8086%E6%A8%A1%E5%BC%8F">wiki: 虚拟8086模式</a>等。</p>
<p>1） 计算机上电，BIOS初始化中断向量表后，会将启动设备的第一个扇区（即引导扇区）读入内存地址0x7c00（31KB)处，并跳转到此处开始执行。而为了方便加载主模块，引导程序首先会将自己移动到内存相对靠后的位置，如linux0.11的bootsect程序先将自己移动到0x90000(576KB)处。这样先移动是多此一举的。</p>
<ul>
<li>解决方案：在保证可靠性的前提下尽量扩大实地址模式下BIOS可访问的内存的范围，如引导扇区加载到0x90000等内存高地址处而不是0x7c00。</li>
</ul>
<p>2） 计算机上电后，ROM BIOS会在物理内存0处初始化中断向量表，其中有256个中断向量，每个中断向量占用4字节，共1KB，在物理内存地址0x000 - ox3ff处，这些中断向量供BIOS中断使用。这就导致了一个问题，如果操作系统的引导程序在加载操作系统时使用了BIOS中断来获取或者显示一些信息时，这1KB地址不能被覆盖。然而操作系统的主模块为了让其中代码地址等于实际的物理地址，需要将其加载到内存0x0000处。所以操作系统在加载时需要先将主模块加载到内存中不与BIOS中断向量表冲突的地方，之后可以覆盖中断向量表时才将其移动到内存起始处，如Linux0.11的System模块就是在bootsect程序中先加载到0x10000,之后在setup程序中移到0x0000处。 这样先加载到另外地方之后再移动到内存起始位置是多此一举的。</p>
<ul>
<li>解决方案：可以将BIOS中断向量表放到实模式下能寻址内存的其他地方，操作系统引导程序直接将操作系统的主模块读到内存的起始处。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200208110055585.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200208110730725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE2Njk1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="bootsect-s-屏幕输出"><a href="#bootsect-s-屏幕输出" class="headerlink" title="bootsect.s 屏幕输出"></a>bootsect.s 屏幕输出</h2><blockquote>
<p>代码中以 <code>!</code> 开头的行都是注释，实际在写代码时可以忽略。</p>
</blockquote>
<p>首先来看完成屏幕显示的关键代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">! 首先读入光标位置</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">! 显示字符串 “Hello OS world, my name is LZJ”</span><br><span class="line">! 要显示的字符串长度</span><br><span class="line">    mov cx,#36</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg1</span><br><span class="line">! es:bp 是显示字符串的地址</span><br><span class="line">! 相比与 linux-0.11 中的代码，需要增加对 es 的处理，因为原代码中在输出之前已经处理了 es</span><br><span class="line">    mov ax,#0x07c0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">! 设置一个无限循环</span><br><span class="line">inf_loop:</span><br><span class="line">    jmp inf_loop</span><br></pre></td></tr></table></figure>

<p>这里需要修改的是字符串长度，即用需要输出的字符串长度替换 <code>mov cx,#24</code> 中的 24。要注意：除了我们设置的字符串 msg1 之外，还有三个换行 + 回车，一共是 6 个字符。比如这里 <code>Hello OS world, my name is LZJ</code> 的长度是 30，加上 6 后是 36，所以代码应该修改为 <code>mov cx,#36</code>。</p>
<p>接下来就是修改输出的字符串了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">! msg1 处放置字符串</span><br><span class="line">msg1:</span><br><span class="line">! 换行 + 回车</span><br><span class="line">    .byte   13,10</span><br><span class="line">    .ascii  &quot;Hello OS world, my name is LZJ&quot;</span><br><span class="line">! 两对换行 + 回车</span><br><span class="line">    .byte   13,10,13,10</span><br><span class="line"></span><br><span class="line">! boot_flag 必须在最后两个字节</span><br><span class="line">.org 510</span><br><span class="line">! 设置引导扇区标记 0xAA55</span><br><span class="line">! 必须有它，才能引导</span><br><span class="line">boot_flag:</span><br><span class="line">    .word   0xAA55</span><br></pre></td></tr></table></figure>

<p>将 <code>.org 508</code> 修改为 <code>.org 510</code>，是因为这里不需要 <code>root_dev: .word ROOT_DEV</code>，为了保证 <code>boot_flag</code> 一定在最后两个字节，所以要修改 <code>.org</code>。</p>
<p>完整的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#36</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg1</span><br><span class="line">    mov ax,#0x07c0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">inf_loop:</span><br><span class="line">    jmp inf_loop</span><br><span class="line">msg1:</span><br><span class="line">    .byte   13,10</span><br><span class="line">    .ascii  &quot;Hello OS world, my name is LZJ&quot;</span><br><span class="line">    .byte   13,10,13,10</span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word   0xAA55</span><br></pre></td></tr></table></figure>

<p>接着执行下面两个命令来编译和链接 bootsect.s。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> as86 -0 -a -o bootsect.o bootsect.s</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ld86 -0 -s -o bootsect bootsect.o</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>-0</code>（注意：这是数字 0，不是字母 O）表示生成 8086 的 16 位目标程序，<code>-a</code> 表示生成与 GNU as 和 ld 部分兼容的代码，<code>-s</code> 告诉链接器 ld86 去除最后生成的可执行文件中的符号信息。</p>
<p>如果这两个命令没有任何输出，说明编译与链接都通过了。</p>
<p>Ubuntu 下用 <code>ls -l</code> 可列出下面的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw--x--x    1  root  root  544  Jul  25  15:07   bootsect</span><br><span class="line">-rw------    1  root  root  257  Jul  25  15:07   bootsect.o</span><br><span class="line">-rw------    1  root  root  686  Jul  25  14:28   bootsect.s</span><br></pre></td></tr></table></figure>

<p>需要留意的文件是 bootsect ，它的大小是 544 字节，而引导程序必须要正好占用一个磁盘扇区，即 512 个字节。造成多了 32 个字节的原因是 ld86 产生的是 Minix 可执行文件格式，这样的可执行文件处理文本段、数据段等部分以外，还包括一个 Minix 可执行文件头部，它的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a_magic[<span class="number">2</span>];  <span class="comment">//执行文件魔数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a_cpu;       <span class="comment">//CPU标识号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a_hdrlen;    <span class="comment">//头部长度，32字节或48字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a_unused;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> a_version;</span><br><span class="line">    <span class="keyword">long</span> a_text; <span class="keyword">long</span> a_data; <span class="keyword">long</span> a_bss; <span class="comment">//代码段长度、数据段长度、堆长度</span></span><br><span class="line">    <span class="keyword">long</span> a_entry;    <span class="comment">//执行入口地址</span></span><br><span class="line">    <span class="keyword">long</span> a_total;    <span class="comment">//分配的内存总量</span></span><br><span class="line">    <span class="keyword">long</span> a_syms;     <span class="comment">//符号表大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>算一算：6 char（6 字节）+ 1 short（2 字节） + 6 long（24 字节）= 32，正好是 32 个字节，去掉这 32 个字节后就可以放入引导扇区了（这是 <code>tools/build.c</code> 的用途之一）。</p>
<p>对于上面的 Minix 可执行文件，其 a_magic[0]=0x01，a_magic[1]=0x03，a_flags=0x10（可执行文件），a_cpu=0x04（表示 Intel i8086/8088，如果是 0x17 则表示 Sun 公司的 SPARC），所以 bootsect 文件的头几个字节应该是 01 03 10 04。为了验证一下，Ubuntu 下用命令“hexdump -C bootsect”可以看到：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00000000  01 03 10 04 20 00 00 00  00 02 00 00 00 00 00 00  |.... ...........|</span><br><span class="line">00000010  00 00 00 00 00 00 00 00  00 82 00 00 00 00 00 00  |................|</span><br><span class="line">00000020  b8 c0 07 8e d8 8e c0 b4  03 30 ff cd 10 b9 17 00  |.........0......|</span><br><span class="line">00000030  bb 07 00 bd 3f 00 b8 01  13 cd 10 b8 00 90 8e c0  |....?...........|</span><br><span class="line">00000040  ba 00 00 b9 02 00 bb 00  02 b8 04 02 cd 13 73 0a  |..............s.|</span><br><span class="line">00000050  ba 00 00 b8 00 00 cd 13  eb e1 ea 00 00 20 90 0d  |............. ..|</span><br><span class="line">00000060  0a 53 75 6e 69 78 20 69  73 20 72 75 6e 6e 69 6e  |.Sunix is runnin|</span><br><span class="line">00000070  67 21 0d 0a 0d 0a 00 00  00 00 00 00 00 00 00 00  |g!..............|</span><br><span class="line">00000080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|</span><br><span class="line">00000220</span><br></pre></td></tr></table></figure>

<p>接下来干什么呢？是的，要去掉这 32 个字节的文件头部（<code>tools/build.c</code> 的功能之一就是这个）！随手编个小的文件读写程序都可以去掉它。不过，懒且聪明的人会在 Ubuntu 下用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd bs=1 <span class="keyword">if</span>=bootsect of=Image skip=32</span><br></pre></td></tr></table></figure>

<p>生成的 Image 就是去掉文件头的 bootsect。</p>
<p>去掉这 32 个字节后，将生成的文件拷贝到 linux-0.11 目录下，并一定要命名为“Image”（注意大小写）。然后就“run”吧！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前的工作路径为 .../oslab/linux-0.11/boot/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将刚刚生成的 Image 复制到 linux-0.11 目录下</span></span><br><span class="line">$ cp ./Image ../Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 oslab 目录中的 run 脚本</span></span><br><span class="line">$ ../../run</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/userid13labid374time1421133611337" alt="bootsect 引导后的系统启动情况"></p>
<blockquote>
<p>run时出错：No bootable device</p>
<p><img src="C:/Users/fdxr1/AppData/Roaming/Typora/typora-user-images/image-20210419083654490.png"></p>
</blockquote>
<h1 id="实验二、"><a href="#实验二、" class="headerlink" title="实验二、"></a>实验二、</h1>	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2021/computer-architecture-hitlabs/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2021/My-favourite-things/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2021-04-06 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/操作系统/">操作系统<span>1</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/实验/">实验<span>2</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-article-text">实验环境</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-article-text">参考资料</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E7%86%9F%E6%82%89%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-article-text">熟悉实验环境</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#1-%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8"><span class="toc-article-text">1. 编译内核</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#2-%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-article-text">2. 运行与调试</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%EF%BC%881%EF%BC%89%E6%B1%87%E7%BC%96%E7%BA%A7%E8%B0%83%E8%AF%95"><span class="toc-article-text">（1）汇编级调试</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%EF%BC%882%EF%BC%89C-%E8%AF%AD%E8%A8%80%E7%BA%A7%E8%B0%83%E8%AF%95"><span class="toc-article-text">（2）C 语言级调试</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#3-%E6%96%87%E4%BB%B6%E4%BA%A4%E6%8D%A2"><span class="toc-article-text">3. 文件交换</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#FAQ"><span class="toc-article-text">FAQ</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="toc-article-text">实验一、操作系统引导</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="toc-article-text">基本内容</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E8%AE%A8%E8%AE%BA"><span class="toc-article-text">讨论</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#bootsect-s-%E5%B1%8F%E5%B9%95%E8%BE%93%E5%87%BA"><span class="toc-article-text">bootsect.s 屏幕输出</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E3%80%81"><span class="toc-article-text">实验二、</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2021 AYu
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
