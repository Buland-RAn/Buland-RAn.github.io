<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + GitHub Pages 博客搭建记录</title>
    <url>//2020/hexo-githubPages-setUp-record.html</url>
    <content><![CDATA[<p>很早就有建一个自己的博客网站的想法了，可能也是想可以倒逼自己多写点东西吧。从安装hexo开始、更换主题、添加功能和第三方服务、部署到github pages上，一步步完善自己的博客。期间踩到了数不清的坑，历时一个月，终于把博客的雏形给做出来了。    <a id="more"></a></p>
<br>

<h1 id="搭建框架与部署"><a href="#搭建框架与部署" class="headerlink" title="搭建框架与部署"></a>搭建框架与部署</h1><p>参考 <a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=2359438930998851478">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a>。</p>
<br>

<h1 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h1><h2 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h2><p>参考 <a href="https://hexo.io/zh-cn/docs/front-matter">hexo中文文档</a>。</p>
<p>在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p>
<p>WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> Diary</span><br><span class="line"><span class="bullet">  -</span> Life</span><br></pre></td></tr></table></figure>

<p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>[Diary, PlayStation]</span><br><span class="line"><span class="bullet">- </span>[Diary, Games]</span><br><span class="line"><span class="bullet">- </span>[Life]</span><br></pre></td></tr></table></figure>

<p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>
<h2 id="相对路径引用的标签"><a href="#相对路径引用的标签" class="headerlink" title="相对路径引用的标签"></a>相对路径引用的标签</h2><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。</p>
<p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">%</span> asset_img <span class="built_in">example</span>.jpg This <span class="built_in">is</span> an <span class="built_in">example</span> <span class="built_in">image</span> <span class="symbol">%</span>&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>
<h2 id="URL-中的分类和标签「翻译」成英文"><a href="#URL-中的分类和标签「翻译」成英文" class="headerlink" title="URL 中的分类和标签「翻译」成英文"></a>URL 中的分类和标签「翻译」成英文</h2><p>参考 <a href="https://github.com/hexojs/hexo/issues/1162">hexo issues</a>。</p>
<p>在<code>_config.yml</code>的<code># Category &amp; Tag</code>一项下面的<code>tag_map</code>和<code>category_map</code>下面这样配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span> </span><br><span class="line">    <span class="string">Linux操作系统:</span> <span class="string">Linux-OS</span></span><br><span class="line">    <span class="string">中文分类:</span> <span class="string">英文分类</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line">    <span class="string">中文标签:</span> <span class="string">英文标签</span></span><br></pre></td></tr></table></figure>


<h2 id="添加网站图标"><a href="#添加网站图标" class="headerlink" title="添加网站图标"></a>添加网站图标</h2><ol>
<li><p>选择好自己的图标，没有的话可以去 <a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a> 挑一个。</p>
</li>
<li><p>将下载的图片在 <a href="https://www.websiteplanet.com/zh-hans/webtools/favicon-generator/">网站图标生成</a> 上转换格式。</p>
</li>
<li><p>把它放入主题文件夹下面的 source/images/ 下面</p>
</li>
<li><p>在主题配置文件中修改</p>
</li>
</ol>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/Snipaste_2020-08-24_20-22-36.png" alt="修改favicon配置"></p>
<h2 id="更改文章url为英文"><a href="#更改文章url为英文" class="headerlink" title="更改文章url为英文"></a>更改文章url为英文</h2><p>在站点的<code>_config.yml</code>中，生成的文章链接默认为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>将<code>/:title/</code>替换为<code>/:urlname/</code></p>
</li>
<li><p>更改<code>permalink_defaults</code></p>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line">  <span class="attr">urlname:</span> <span class="string">index</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>之后写文章时在font-matter处加上<code>urlname: XXX</code>就可以了</li>
</ol>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/Snipaste_2020-09-06_10-31-34.png" alt="urlname"></p>
<br>

<p>还可以在<code>scaffolds/post.md</code>里配上这个字段</p>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/Snipaste_2020-09-06_10-33-53.png" alt="添加创建模板字段"></p>
<p>这样，以后<code>hexo n post &quot;&quot;</code>的时候就自动出现在font-matter里面了。</p>
<p>！注意：以前的文章也需要加上urlname字段，内容与文章标题保持一致，否则就找不到了噢。（或者你也可以选择全部重建）</p>
<br>


<h1 id="添加小功能"><a href="#添加小功能" class="headerlink" title="添加小功能"></a>添加小功能</h1><h2 id="添加文章时自动打开编辑器"><a href="#添加文章时自动打开编辑器" class="headerlink" title="添加文章时自动打开编辑器"></a>添加文章时自动打开编辑器</h2><p>参考 <a href="%5Bhttps://notes.doublemine.me/2015-06-29-Hexo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8.html%5D(https://notes.doublemine.me/2015-06-29-Hexo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8.html)">Hexo 添加文章时自动打开编辑器 - Doublemine</a> 。以下为博客内容：</p>
<ul>
<li>首先在Hexo目录下的<code>scripts</code>目录中创建一个JavaScript脚本文件。</li>
<li>如果没有这个<code>scripts</code>目录，则新建一个。</li>
<li><code>scripts</code>目录新建的JavaScript脚本文件可以任意取名。</li>
</ul>
<p>通过这个脚本，我们用其来监听<code>hexo new</code>这个动作，并在检测到<code>hexo new</code>之后，执行编辑器打开的命令。</p>
<p>如果你是windows平台的Hexo用户，则将下列内容写入你的脚本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).exec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hexo 2.x 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">&#x27;new&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">  spawn(<span class="string">&#x27;start  &quot;markdown编辑器绝对路径.exe&quot; &#x27;</span> + path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hexo 3 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">&#x27;new&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  spawn(<span class="string">&#x27;start  &quot;markdown编辑器绝对路径.exe&quot; &#x27;</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你是Mac平台Hexo用户，则将下列内容写入你的脚本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).exec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hexo 2.x 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">&#x27;new&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">    exec(<span class="string">&#x27;open -a &quot;markdown编辑器绝对路径.app&quot; &#x27;</span> + path);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hexo 3 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">&#x27;new&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    exec(<span class="string">&#x27;open -a &quot;markdown编辑器绝对路径.app&quot; &#x27;</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>保存并退出脚本之后，在命令行中键入：   </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new &quot;auto open editor test&quot;</span><br></pre></td></tr></table></figure>

<p>就可以打开编辑器了。</p>
<h2 id="主动推送Hexo博客新链接至搜索平台"><a href="#主动推送Hexo博客新链接至搜索平台" class="headerlink" title="主动推送Hexo博客新链接至搜索平台"></a>主动推送Hexo博客新链接至搜索平台</h2><p>使用插件 hexo-submit-urls-to-search-engine ，查看 <a href="https://cjh0613.com/20200603HexoSubmitUrlsToSearchEngine.html">中文文档</a>。</p>
<p>首先明确</p>
<p>1）站点配置文件，位于站点文件夹根目录内<code>~/blog/_config.yml</code></p>
<p>2）主题配置文件，位于主题文件夹根目录内<code>~/blog/themes/next/_config.yml</code></p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>有两个插件我比较喜欢，一个可以<a href="https://github.com/kchen0x/hexo-reference">悬浮显示</a>，一个比较<a href="https://github.com/LouisBarranqueiro/hexo-footnotes">简洁</a> 。</p>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/Snipaste_2020-08-20_16-18-02.png" alt="hexo两个脚注插件"><img src="/2020/hexo-githubPages-setUp-record.htm/Snipaste_2020-08-20_16-18-11.png" alt="悬浮显示" style="zoom:50%;"></p>
<p><strong>Markdown</strong> 语法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">basic footnote[^1]</span><br><span class="line">here is an inline footnote[<span class="string">^2</span>](<span class="link">inline footnote</span>)</span><br><span class="line">and another one[^3]</span><br><span class="line">and another one[^4]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">basic footnote content</span></span><br><span class="line">[<span class="symbol">^3</span>]: <span class="link">paragraph</span></span><br><span class="line">footnote</span><br><span class="line">content</span><br><span class="line">[<span class="string">^4</span>]: footnote content with some [<span class="string">markdown</span>](<span class="link">https://en.wikipedia.org/wiki/Markdown</span>)</span><br></pre></td></tr></table></figure>

<h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><p><a href="https://www.jianshu.com/p/3e200908b9fc">各种评论系统的比较</a> ，我使用的是 valine。支持Markdown，重点是好看！</p>
<p>参考 <a href="%5Bhttps://qianfanguojin.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/%5D(https://qianfanguojin.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/)">为Next主题添加Valine评论系统</a> 。</p>
<p>我这里踩了一个坑，之前在LeanCloud上操作过，不知道是设置了些什么账号出了问题，之后我换了一个节点重新新建一个项目，填入新的appId和appKey后就好了。</p>
<h2 id="站点访问统计显示"><a href="#站点访问统计显示" class="headerlink" title="站点访问统计显示"></a>站点访问统计显示</h2><h2 id="开启文章评分"><a href="#开启文章评分" class="headerlink" title="开启文章评分"></a>开启文章评分</h2><br>

<h1 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h1><h2 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h2><p>扒自 <a href="http://yearito.cn/posts/hexo-theme-beautify.html">Hexo 搭建个人博客系列：主题美化篇</a> 。</p>
<p>以下为四个比较常用的鼠标点击特效：</p>
<ul>
<li><a href="http://yearito.cn/posts/hexo-theme-beautify.html#%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88-1">礼花特效</a></li>
<li><a href="http://yearito.cn/posts/hexo-theme-beautify.html#%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88-2">爆炸特效</a></li>
<li><a href="http://yearito.cn/posts/hexo-theme-beautify.html#%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88-3">浮出爱心</a></li>
<li><a href="http://yearito.cn/posts/hexo-theme-beautify.html#%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88-4">浮出文字</a></li>
</ul>
<p><a href="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/cursor-fireworks.gif"><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/cursor-fireworks.gif" alt="img" style="zoom:50%; display:inline;"></a>   <a href="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/cursor-explosion.gif"> <img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/cursor-explosion.gif" alt="img" style="zoom:50%; display:inline;"></a>   </p>
<p>点击下方链接下载相应的脚本，并置于 themes\next\source\js\cursor\ 目录下：</p>
<p><a href="https://script-1256884783.file.myqcloud.com/cursor/fireworks.js">礼花特效</a>                  <a href="https://script-1256884783.file.myqcloud.com/cursor/explosion.min.js">爆炸特效</a>                   <a href="https://script-1256884783.file.myqcloud.com/cursor/love.min.js">浮出爱心</a>                  <a href="https://script-1256884783.file.myqcloud.com/cursor/text.js">浮出文字</a></p>
<p>在主题自定义布局文件中添加以下代码：</p>
<p>themes\next\layout_custom\custom.swig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% if theme.cursor_effect &#x3D;&#x3D; &quot;fireworks&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;explosion&quot; %&#125;</span><br><span class="line">  &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;explosion.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;love&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;love.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect &#x3D;&#x3D; &quot;text&quot; %&#125;</span><br><span class="line">  &lt;script async src&#x3D;&quot;&#x2F;js&#x2F;cursor&#x2F;text.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<p>themes\next\layout_layout.swig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            ...</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;exturl.swig&#39; %&#125;</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;bookmark.swig&#39; %&#125;</span><br><span class="line">      &#123;% include &#39;_third-party&#x2F;copy-code.swig&#39; %&#125;</span><br><span class="line"></span><br><span class="line">+     &#123;% include &#39;_custom&#x2F;custom.swig&#39; %&#125;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">  &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中添加以下代码：</p>
<p>themes\next_config.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mouse click effect: fireworks | explosion | love | text</span></span><br><span class="line"><span class="attr">cursor_effect:</span> <span class="string">fireworks</span></span><br></pre></td></tr></table></figure>

<p>这样即可在配置文件中一键快速切换鼠标点击特效。</p>
<p>如果从本地加载 JS 脚本速度较慢，可以考虑将脚本放到 CDN 上再引入。</p>
<br>


<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="安装置顶插件"><a href="#安装置顶插件" class="headerlink" title="安装置顶插件"></a>安装置顶插件</h2><p>替换给文章排序索引的原有插件 hexo-generator-index为hexo-generator-indexed</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">npm uni hexo-generator-<span class="built_in">index</span> --<span class="keyword">save</span> &amp;&amp; npm i hexo-generator-indexed --<span class="keyword">save</span></span><br></pre></td></tr></table></figure>

<p>报错：</p>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/image-20200817162704023.png" alt="报错信息"></p>
<p>解决方案：</p>
<p>1.fsevents不在package.json里，但是仍然安装了。我的系统是Windows系统，fsevents是darwin的可选依赖。博客主人在里面安装了fsevents相关依赖库，所以到这边也就安装到我的windows上了。“检查你的package.json 文件中是不是有fsevents相关依赖，删除即好。”但我的package.json文件中并没有，所以采取了第二种方案。</p>
<p>2.在package.json中加入下面代码，将fsevents依赖变为可选的。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;optionalDependencies&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;fsevents&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步中据说有一个坑，“需要删除package_lock.json,否则标记会失效，所有依赖都将被安装。”</p>
<p>“I’m seeing this today with npm 5.3.0. npm install –no-optional works IIF a package-lock.json does not exist. If the package-lock.json file exists, then the flag is ignored and all dependencies get installed.”</p>
<h2 id="生成静态文件错误"><a href="#生成静态文件错误" class="headerlink" title="生成静态文件错误"></a>生成静态文件错误</h2><p>执行 <code>hexo g</code> 的时候出现了下面的错误</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ERROR Template render error: (Y:\Blog\hexo3\themes\next\layout\post.swig)</span><br><span class="line"></span><br><span class="line"><span class="function">Error: <span class="title">Unable</span> <span class="title">to</span> <span class="title">call</span> `<span class="title">value</span>[&quot;<span class="title">split</span>&quot;]`, <span class="title">which</span> <span class="title">is</span> <span class="title">undefined</span> <span class="title">or</span> <span class="title">falsey</span></span></span><br></pre></td></tr></table></figure>

<p>网上搜了很多类似的问题都没有解决问题，后来看到一篇文章说是博客的格式有误，出现了识别不了的记号。我将博客移出后再执行果然没有报错了。但是对照别人写的<code>.md</code>文件，我的博客没有什么格式不正确的地方。</p>
<p>之后我又尝试了将<code>主题配置文件</code>恢复成初始状态，这样解决了问题，但我不知道是哪里错了，可能是改的过程中将格式写错了。</p>
<h2 id="本地与部署不一致问题"><a href="#本地与部署不一致问题" class="headerlink" title="本地与部署不一致问题"></a>本地与部署不一致问题</h2><p>参考 <a href="https://blog.csdn.net/GAI159/article/details/105128186/">解决hexo本地与部署不一致问题</a>。</p>
<p>可能原因：</p>
<p>1.URL配置错误(写上自己的博客地址)</p>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/2020-08-19_11-33-46.png" alt="站点配置信息"></p>
<p>2.部署到远程服务器没来得及更新，过一段时间再看</p>
<p>3.浏览器保存了之前的数据，清除浏览器缓存后再强制刷新Shift+F5 （√）</p>
<p>4.如果上面几种都还没有解决问题，也可能是branch错误 </p>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/20200326212416815.jpg" alt="推到另一个分支"></p>
<p>之后在hexo站点配置文件_config.yml中找到branch，将master改为刚刚新建的分支名。</p>
<h2 id="博客图片显示不出"><a href="#博客图片显示不出" class="headerlink" title="博客图片显示不出"></a>博客图片显示不出</h2><p>我一般是采用截图后直接将图片粘贴到博客中的做法，这样当然找不到了，图片文件都没有到github里面去。</p>
<p>解决办法：</p>
<p>安装插件 </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>在站点配置文件*/_config.yml* 中配置指令 <code>post_asset_folder: true</code> 这样在每次新建文章的时候就会建立同名文件夹, 直接将相应的文章图片放在文件夹内。</p>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/Snipaste_2020-08-19_11-54-33.png" alt="文件结构"></p>
<p>之后引用的时候可以使用markdown语法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">文件结构</span>](<span class="link">hexo-github-pages-博客搭建记录/Snipaste_2020-08-19_11-54-33.png</span>)</span><br></pre></td></tr></table></figure>

<p>也可以使用hexo定义的标签</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">%</span> asset_img <span class="built_in">example</span>.jpg This <span class="built_in">is</span> an <span class="built_in">example</span> <span class="built_in">image</span> <span class="symbol">%</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显示不出archives页面"><a href="#显示不出archives页面" class="headerlink" title="显示不出archives页面"></a>显示不出archives页面</h2><p>archives归档页面显示不出，但只要名字不是这个就没有问题。</p>
<h2 id="文章路径undefined"><a href="#文章路径undefined" class="headerlink" title="文章路径undefined"></a>文章路径undefined</h2><p>将<code>站点配置文件</code> permalink 修改后就好了。</p>
<p><img src="/2020/hexo-githubPages-setUp-record.htm/Snipaste_2020-08-24_22-06-11.png" alt="配置信息"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>半原创</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP字符串匹配算法图解</title>
    <url>//2020/KMP-elaboration.html</url>
    <content><![CDATA[<p>KMP算法是字符串匹配算法中对暴力匹配算法的优化。我尽量用容易理解的方法把它写 &amp; 画清楚。<a id="more"></a></p>
<h1 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h1><p>暴力破解。这是最朴素的一种解决方案：从文本串（即被匹配的大字符串，以下都是）的第一个字符开始，一位一位地与模式串（即搜索的关键字，以下都是）的对应位置相比较。</p>
<p><img src="/2020/KMP-elaboration.htm/%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%951.png" alt="暴力算法"></p>
<p>设文本串(p)的长度为m，模式串(s)的长度为n。i，j分别是指向文本串、模式串的游标。</p>
<p>while（i &lt; m) {</p>
<p>​    if (p[i] != s[j]) {</p>
<p>​        i++;  j = 0;</p>
<p>​    } else {</p>
<p>​        i++;  j++;</p>
<p>​    }</p>
<p>}</p>
<p>但可想而知，这样的匹配算法时间复杂度几乎为O(mn)。但仔细想想，我们确实没必要再比较上图中第二步的a与b，因为在第一步已经比较到了文本串的b，我们应该让程序“记住”它比较过了的东西，在明显与模式串的第一个字符不相同后，就应该去掉第二步。</p>
<p>但我们不能真的去把之前比较过的数据保存起来，那样既增加了空间开销，又没能达到优化的目的。于是，KMP就要登场了，它能帮程序不用像傻子一样（虽然它就是）一个一个地比较下去。</p>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>有一种巧妙的方法。因为假设比较到第k位就失配了（崩了），那么有一个事实是可以确定的：两个串前k-1个字符肯定是相同的。那么！因为模式串是已经定好的，在匹配到j == k时停下来，我们（程序）就知道在文本串中 [i-j, i-1]的字符是什么了。那么知道了以后呢？我们的目的是不要像暴力算法那样一个个比，那就得跳过一些，但又不能把能匹配得上的给跳过了，那么我们就需要看已知的（已经比较过的）文本串中有没有跟模式串开头相同的字符（串）了。<strong>没有的话就可以直接跳过前j个</strong>，有的话就跳到相同的那一部分继续往下比较。</p>
<p>这里面有一个小点，既然我们已经知道其中有连续的几个是与模式串的前缀（即前面连续的几个）是相同的，那么也没必要再比较了，直接从文本串中程序“未知的”那一个位置继续下去。</p>
<p>如下图，前面三个aba已知，同时模式串a又能与aba中第二个a匹配，那么就直接把模式串移到<strong>模式串开头的a与aba中第二个a</strong>匹配的位置，同时把模式串的游标j移到a后面的b，从它开始比较。</p>
<p><img src="/2020/KMP-elaboration.htm/KMP.png" alt="KMP"></p>
<p>可是，问题又来了。怎么要让程序知道应该跳过其中的多少步呢？</p>
<p>这就又要归功于模式串的<u>已知</u>和<u>不变</u>了，我们现在的任务是什么？我们现在的任务就是在一段已知的字符串（即已经比较过的那一段，也即模式串的一个前缀，上图中的aba）中找是不是有（<strong>它的</strong>）前缀后缀相同的地方啊。如上图，前后缀相同的就是a。</p>
<p>相同有什么用呢？因为我们要找相同的这一段恰好就是模式串的前缀，且我们是在这一段字符的下一个字符失配的，我们找到这一个字符串中后面某几位是否与前面的某几位相同，就可以知道这里面有没有我们需要移动模式串的位置再匹配一下的地方了。</p>
<p>那么，我们可以针对模式串建立一个数组 next[]。next[m]里面存储的是若在（模式串）第m位失配，下一次比较中模式串的游标应该要指向的位置。<strong>文本串的游标不变</strong>。当需要用到next[i]时，说明前面i-1个字符都是匹配的，到了第i个不相同，那么就需要在<strong>前i-1个字符组成的字符串中</strong>找是否有相同的前后缀。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>由此可以写出kmp基本代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String p, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="comment">//initNext1(s, next);</span></span><br><span class="line">    initNext2(s, next);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;p.length() &amp;&amp; j&lt;s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 因为将next[0]设置为-1，代表需要移动文本串游标</span></span><br><span class="line">            <span class="comment">// 因此需要将j==0的情况单独抽离出来，防止下标越界（j被赋值为-1）</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == s.length()) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initNext（生成next数组）有两种方法：数学归纳法和先前搜索法。</p>
<h2 id="生成next数组"><a href="#生成next数组" class="headerlink" title="生成next数组"></a>生成next数组</h2><p>将next[0]设置为-1，代表需要移动文本串游标。若设置为0，则在第一个字符就失配的情况下会陷入死循环。next[1] = 0：若第二个字符失配，则将模式串向后移1位，即游标指向0，从头开始。</p>
<h3 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h3><p>假设next[j]已知，求出next[j+1]的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成next数组（数学归纳法）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initNext1</span><span class="params">(String s, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(next.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>, k = next[j];  <span class="comment">// next[0]已经确定，从next[1]开始生成，j=1</span></span><br><span class="line">    <span class="keyword">while</span>(j + <span class="number">1</span> &lt; next.length) &#123;  <span class="comment">// 确定j后面还有字符（存在失配可能）</span></span><br><span class="line">        <span class="keyword">while</span>(k != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j) == s.charAt(k)) &#123; </span><br><span class="line">                next[j+<span class="number">1</span>] = k + <span class="number">1</span>;   <span class="comment">// k=next[j]</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span>) next[j+<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 说明S0 != Sj</span></span><br><span class="line">        j++;</span><br><span class="line">        k = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/KMP-elaboration.htm/next.jpg" alt="next"></p>
<h3 id="向前搜索法"><a href="#向前搜索法" class="headerlink" title="向前搜索法"></a>向前搜索法</h3><p>朴素解法。从前缀 &amp; 后缀的后面开始比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成next数组（向前搜索）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initNext2</span><span class="params">(String s, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(next.length == <span class="number">1</span>) &#123;</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> find = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">int</span> i1 = i, j1 = j;</span><br><span class="line">                <span class="keyword">while</span>(j1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(i1) == s.charAt(j1)) &#123;</span><br><span class="line">                        i1--;</span><br><span class="line">                        j1--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        find = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(find) &#123;</span><br><span class="line">                    next[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) next[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/KMP-elaboration.htm/next2.jpg" alt="next2"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图解</tag>
      </tags>
  </entry>
  <entry>
    <title>if-else的优化</title>
    <url>//2020/null.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="消灭if-else嵌套"><a href="#消灭if-else嵌套" class="headerlink" title="消灭if-else嵌套"></a>消灭if-else嵌套</h1><p><a href="https://juejin.im/post/6844904080104488967">参考出处1</a>：使用设计模式中的<strong>策略模式</strong>来优化针对不同条件进行不同操作的需求。</p>
<p><a href="https://blog.csdn.net/fzy629442466/article/details/85762748">参考出处2</a>: 优化大量的if else 的不同方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if-else</code>一般不建议嵌套超过三层，如果一段代码存在过多的<code>if-else</code>嵌套，代码的可读性就会急速下降，后期维护难度也大大提高。</p>
<h1 id="多条件判断时的if-else选择与排序"><a href="#多条件判断时的if-else选择与排序" class="headerlink" title="多条件判断时的if-else选择与排序"></a>多条件判断时的if-else选择与排序</h1><p><a href="https://www.cnblogs.com/rwg-xs/articles/6213168.html">参考出处</a></p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><h3 id="if-else-语句块的顺序"><a href="#if-else-语句块的顺序" class="headerlink" title="if/else 语句块的顺序"></a>if/else 语句块的顺序</h3><ul>
<li>首先处理正逻辑而不是负逻辑</li>
<li>先处理简单的情况</li>
<li>先处理有趣的或者是可疑的情况</li>
</ul>
<h3 id="通过提早返回减少嵌套"><a href="#通过提早返回减少嵌套" class="headerlink" title="通过提早返回减少嵌套"></a>通过提早返回减少嵌套</h3><h3 id="总结变量"><a href="#总结变量" class="headerlink" title="总结变量"></a>总结变量</h3><ul>
<li>用一个短很多的名字来代替一大块代码，这就是总结变量。</li>
<li>使用德摩根定理,分解复制的判断逻辑</li>
<li>拆分巨大的语句，让语句更容易快速阅读</li>
</ul>
<h3 id="分析函数（或代码块）画出逻辑树"><a href="#分析函数（或代码块）画出逻辑树" class="headerlink" title="分析函数（或代码块）画出逻辑树"></a>分析函数（或代码块）画出逻辑树</h3><p>逻辑树是为了理清复杂if语句逻辑二产生的，结构与哈夫曼树类似：</p>
<p><img src="https://images2015.cnblogs.com/blog/1013328/201612/1013328-20161222224548995-776032877.png" alt="img"> </p>
<p>逻辑树规则：（模块的定义：每一个if/else的分支即为一个模块）</p>
<p>1.每个模块都是一个根结点，每一个根结点都会结束函数运行。</p>
<p>2.同等级的模块（即if语句的正反两面），无子模块的模块（内部无if语句）优先级高于拥有子模块的模块（内部嵌套if语句）</p>
<p>3.同等级和同条件（两个模块都拥有子模块或者都没有子模块）的情况下，使用率高的模块优先级高于使用率低的</p>
<p>4.若模块中包含子模块，子模块的优先级高于父模块。</p>
<p><strong>例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span>(user_result == SUCCESS )&#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">　　<span class="keyword">if</span>( permission_result != SUCCESS)&#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">　　　　reply.WriteErrors(<span class="string">&quot;error reading permissions&quot;</span>);</span><br><span class="line">　　　　reply.Done();</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">   <span class="comment">// 2   </span></span><br><span class="line">　　&#125;</span><br><span class="line">　　reply.WriteErrors(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 1    </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">　　reply.WriteErrors(user_result);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共有</span></span><br><span class="line">reply.Done();</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>根据原则优化：</p>
<ol>
<li><p>2、4两个属于同等级模块，但是由于红色模块中包含一个子模块，所以红色模块优先级低于紫色模块</p>
</li>
<li><p>3模块属于2模块子模块，所以3模块优先级高于2模块</p>
</li>
<li><p>函数的优先级排列由高到低为：4  &gt; 3 &gt; 2</p>
</li>
</ol>
<p>得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(user_result != SUCCESS)&#123;</span><br><span class="line">　　reply.WriteErrors(user_result);</span><br><span class="line">　　reply.Done();</span><br><span class="line">　　<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(permission_result != SUCCESS)&#123;</span><br><span class="line">　　reply.WriteErrors(permission_result);</span><br><span class="line">　　reply.Done();</span><br><span class="line">　　<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.WriteErrors(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">reply.Done();</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼树在多重判定程序中的运用"><a href="#哈夫曼树在多重判定程序中的运用" class="headerlink" title="哈夫曼树在多重判定程序中的运用"></a>哈夫曼树在多重判定程序中的运用</h1><p><a href="https://www.docin.com/p-764063178.html">参考论文</a></p>
<p><img src="/2020/null.htm/%E5%93%88%E5%A4%AB%E6%9B%BC.png" alt="哈夫曼"></p>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="多个「或」等值判断"><a href="#多个「或」等值判断" class="headerlink" title="多个「或」等值判断"></a>多个「或」等值判断</h2><p><a href="https://www.toutiao.com/i6535677221640602125/">参考出处</a></p>
<p>reg.equals(“1”) || reg.equals(“2”) || reg.equals(“3”)||…省去n个</p>
<p>可以借助map或set来进行判断，因为hashmap是一个hash桶，查找的效率是比较快的，不管判断任何值，查询效率基本很稳定。</p>
<p>推荐指定hashmap的长度和需要判断的元素一样多，这样就避免对某一个桶内衍生出多余链表了。</p>
<p><img src="https://p3-tt.byteimg.com/origin/pgc-image/1521705513450288676a8a8?from=pc" alt="Java逻辑条件多个「或」判断时，性能优化小技巧，值得一试"></p>
<p><img src="https://p3-tt.byteimg.com/origin/pgc-image/15217055457025d21af6336?from=pc" alt="Java逻辑条件多个「或」判断时，性能优化小技巧，值得一试"></p>
<h2 id="提前判断返回"><a href="#提前判断返回" class="headerlink" title="提前判断返回"></a>提前判断返回</h2><p>如下语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">   <span class="comment">//dost</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!condition)&#123;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dost</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>避免一些不必要的分支，让代码更精炼。</p>
]]></content>
  </entry>
  <entry>
    <title>java IO与文件操作</title>
    <url>//2020/java-IO&amp;File.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="输入输出类"><a href="#输入输出类" class="headerlink" title="输入输出类"></a>输入输出类</h1><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><h3 id="read-与-read-byte-b"><a href="#read-与-read-byte-b" class="headerlink" title="read() 与 read(byte[] b)"></a>read() 与 read(byte[] b)</h3><p>这个方法是对这个流一个一个字节的读，返回的int就是这个字节的int表示方式。</p>
<p>参考<a href="https://blog.csdn.net/wymrdjm/article/details/78758986">FileInputStream之read方法</a></p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="readLine-与read"><a href="#readLine-与read" class="headerlink" title="readLine()与read()"></a>readLine()与read()</h2><p>功能：读取一个文本行。<br>一定要注意：<br>1、读入的数据要注意有/r或/n或/r/n, readLine返回的字符串中不包含结尾的”\r”,”\n”。<br>2、没有数据时会阻塞，在数据流异常或断开时才会返回null<br>3、使用socket之类的数据流时，要避免使用readLine()，以免为了等待一个换行/回车符而一直阻塞<br>4、readLine()是一个阻塞函数，当没有数据读取时，就一直会阻塞在那，而不是返回null<br>5、readLine()只有在数据流发生异常或者另一端被close()掉时，才会返回null值。<br>6、如果不指定buffer大小，则readLine()使用的buffer有8192个字符。在达到buffer大小之前，只有遇到”/r”、”/n”、”/r/n”才会返回。<br>7、该方法读取一行文本，当遇到换行符”\n”,回车符”\r”或者回车符后面紧跟着换行符时，该行结束并返回。没有数据时，将会一直处于等待状态。因此在进行网络连接时，应该避免使用该方法。</p>
<p>read()<br>功能：读取单个字符的个数，如果已经读完的话会返回-1 (其范围从 0 到 65535 )</p>
]]></content>
  </entry>
  <entry>
    <title>图论-过河问题及其变形</title>
    <url>//2020/Graph-CrossRiver.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="图论-安全过河的最短路径问题"><a href="#图论-安全过河的最短路径问题" class="headerlink" title="图论-安全过河的最短路径问题"></a>图论-安全过河的最短路径问题</h1><p><a href="https://www.cnblogs.com/lfri/p/9866992.html">原博客</a></p>
<h2 id="农夫过河问题"><a href="#农夫过河问题" class="headerlink" title="农夫过河问题"></a>农夫过河问题</h2><p><strong>问题描述</strong></p>
<p>一个农夫带着一头狼、一头羊、一颗白菜过河。他面前只有一条船，只能容纳他和一件物品，只有农夫会划船。如果农夫不在场，狼会吃羊、羊会吃白菜，农夫在场则不会。求将所有物品运到对岸的方案。</p>
<p><strong>解题思路</strong></p>
<p>根据物品的位置定义状态，若在左岸记为1，右岸记为0，于是最终方案就是(1,1,1,1)–&gt;(0,0,0,0)所经过的路径。</p>
<p>1、定义状态</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028191311144-1211710443.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028191311144-1211710443.png" alt="img"></a></p>
<p>2、列举所有状态（人、狼、羊、菜）</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028191459048-317298943.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028191459048-317298943.png" alt="img"></a></p>
<p>3、删除不合理的状态（狼和羊、羊和菜）</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028191647740-1828632698.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028191647740-1828632698.png" alt="img"></a></p>
<p>4、连边（模拟一次渡河）</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028192013516-1740822628.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028192013516-1740822628.png" alt="img"></a></p>
<p>5、寻找路径</p>
<p>寻找(1111)–&gt;(0000)的边，可以用寻路算法如bfs、dfs,如果要求最短路可以用最短路算法如bfs、Dijsktra等，当然这里图很简单，可直接观察出来。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">(<span class="number">1111</span>)</span>--&gt;</span><span class="function"><span class="params">(<span class="number">0101</span>)</span>--&gt;</span><span class="function"><span class="params">(<span class="number">1101</span>)</span>--&gt;</span><span class="function"><span class="params">(<span class="number">0001</span>)</span>--&gt;</span><span class="function"><span class="params">(<span class="number">1011</span>)</span>--&gt;</span><span class="function"><span class="params">(<span class="number">0010</span>)</span>--&gt;</span><span class="function"><span class="params">(<span class="number">1010</span>)</span>--&gt;</span>(<span class="number">0000</span>)（两条最短路之一）</span><br><span class="line">       左岸                                 右岸</span><br><span class="line"><span class="number">1</span>、人  狼  羊 花                           空</span><br><span class="line"><span class="number">2</span>、狼  花                                 人 羊</span><br><span class="line"><span class="number">3</span>、人  狼 花                               羊</span><br><span class="line"><span class="number">4</span>、花                                     人 狼  羊</span><br><span class="line"><span class="number">5</span>、人  羊  花                              狼</span><br><span class="line"><span class="number">6</span>、羊                                     人 花  狼</span><br><span class="line"><span class="number">7</span>、人 羊                                  狼 花</span><br><span class="line"><span class="number">8</span>、空                                     狼 花 人 羊   </span><br></pre></td></tr></table></figure>



<h2 id="传教士与吃人恶魔的问题"><a href="#传教士与吃人恶魔的问题" class="headerlink" title="传教士与吃人恶魔的问题"></a>传教士与吃人恶魔的问题</h2><p><strong>问题描述</strong></p>
<p>有三个传教士和三个吃人恶魔要渡过一条河，河中有一条船，只能装下两个人。在任何地方（无论是岸边还是船上），如果吃人恶魔数量多于传教士数量，吃人恶魔就会吃掉传教士。问：怎么才能让这些都安全过河？</p>
<p><strong>解题思路</strong></p>
<p>1、定义状态</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028194640506-192088956.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028194640506-192088956.png" alt="img"></a></p>
<p>2、列举所有状态</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028194800042-757542463.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028194800042-757542463.png" alt="img"></a></p>
<p>3、删除不合理状态</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028194856707-156878733.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028194856707-156878733.png" alt="img"></a></p>
<p>4、连边（模拟依次渡河变化）</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028195050222-475204241.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028195050222-475204241.png" alt="img"></a></p>
<p>5、寻找路径</p>
<p>寻找(33 L 00)–&gt;(00 R 33)的路径</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">其中一条路径</span><br><span class="line">(<span class="number">33</span> L <span class="number">00</span>)--&gt;(<span class="number">31</span> R <span class="number">01</span>)--&gt;(<span class="number">32</span> L <span class="number">01</span>)--&gt;(<span class="number">30</span> R <span class="number">03</span>)--&gt;(<span class="number">31</span> L <span class="number">02</span>)--&gt;(<span class="number">11</span> R <span class="number">22</span>)--&gt;(<span class="number">22</span> L <span class="number">01</span>)--&gt;(<span class="number">02</span> R <span class="number">31</span>)--&gt;(<span class="number">03</span> L <span class="number">30</span>)--&gt;(<span class="number">01</span> R <span class="number">32</span>)--&gt;(<span class="number">02</span> L <span class="number">31</span>)--&gt;(<span class="number">00</span> R <span class="number">33</span>)</span><br><span class="line"><span class="number">1</span>、两个吃人恶魔过河</span><br><span class="line"><span class="number">2</span>、一个吃人恶魔回来</span><br><span class="line"><span class="number">3</span>、两个吃人恶魔过河</span><br><span class="line"><span class="number">4</span>、一个吃人恶魔回来</span><br><span class="line"><span class="number">5</span>、两个传教士过河</span><br><span class="line"><span class="number">6</span>、一个传教士和一个吃人恶魔回来</span><br><span class="line"><span class="number">7</span>、两个传教士回来</span><br><span class="line"><span class="number">8</span>、一个吃人恶魔回去</span><br><span class="line"><span class="number">9</span>、两个吃人恶魔过河</span><br><span class="line"><span class="number">10</span>、一个吃人恶魔回去</span><br><span class="line"><span class="number">11</span>、两个吃人恶魔过河</span><br></pre></td></tr></table></figure>



<h2 id="四人过桥问题"><a href="#四人过桥问题" class="headerlink" title="四人过桥问题"></a>四人过桥问题</h2><p><strong>问题描述</strong></p>
<p>在一个漆黑的夜里，四位旅游者来到一座狭窄而没有护栏的桥边，如果不借助手电筒的话，大家是无论也不敢过去。不幸的是四个人中只有一只手电筒，而桥窄得只够两个人同时通过。如果各自单独过桥得话，四个人所需要的时间分别是1、2、5、10分钟，如果两个人同时过桥，所需要的时间是较慢的那个人单独行动时的时间。问：如何设计一个方案，让四个人尽快过桥。</p>
<p><strong>解题思路</strong></p>
<p>与前面两个相比，这次不仅要求方案，同时要求时间最短。 </p>
<p>同样需要定义状态，四个人+手电筒的位置</p>
<p>1、定义状态</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028230252029-80793767.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028230252029-80793767.png" alt="img"></a></p>
<p>2、建图</p>
<p>分为每次通过一个人和每次两个人，都是带权无向边。</p>
<p>(下面只连接了与(01111)的边)</p>
<p><a href="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028230534537-2018916150.png"><img src="https://img2018.cnblogs.com/blog/1365470/201810/1365470-20181028230534537-2018916150.png" alt="img"></a></p>
<p>3、寻找最短路</p>
<p>寻找(L 1111)–&gt;(R 0000)的最短路，即最短路算法中(01111)–&gt;(10000)的最短路，以下是利用Dijstra算法的解决方法。</p>
<p>最终答案为(2 + 1 + 10 + 2 + 2) = 17.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义图中结点</span></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> u, d;            <span class="comment">//该节点的编号与距离</span></span><br><span class="line">    bool operator &lt; (<span class="keyword">const</span> Node x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  d &gt; x.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边结构体的定义</span></span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">32</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E = <span class="number">32</span> * <span class="number">32</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dis[V];            <span class="comment">//源到各顶点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> vis[V];            <span class="comment">//记录是否被收录，用来代替集合S</span></span><br><span class="line"><span class="keyword">int</span> head[V];          <span class="comment">//head[i]表示顶点i的第一条边的数组下标，&quot;-1&quot;表示顶点i没有边</span></span><br><span class="line">Edge edge[E];</span><br><span class="line"></span><br><span class="line"><span class="function">inline <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> w, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[id].to = b;</span><br><span class="line">    edge[id].w = w;</span><br><span class="line">    edge[id].next = head[a];</span><br><span class="line">    head[a] = id;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s为起点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijsktra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt;q;            <span class="comment">//取出集合T中的最小值</span></span><br><span class="line">    memset(vis, <span class="number">0</span>, sizeof(vis));</span><br><span class="line">    memset(dis, INF, sizeof(dis));</span><br><span class="line"></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(Node&#123; s, dis[s] &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node x = q.top(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = x.u;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis[u])    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        vis[u] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != -<span class="number">1</span>; i = edge[i].next)    <span class="comment">//松弛与u直接相邻的顶点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[u] + w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(Node&#123; v,dis[v] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> score[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span> &#125;;   <span class="comment">//每个人单独行动的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//建图</span></span><br><span class="line">    memset(head, -<span class="number">1</span>, sizeof(head));</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bits[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)  bits[j] = (i &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//一次走一个人</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)  <span class="keyword">if</span> (bits[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = i - (<span class="number">1</span> &lt;&lt; j) + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">int</span> w = score[j];</span><br><span class="line">            AddEdge(i, tmp, w, id++);</span><br><span class="line">            AddEdge(tmp, i, w, id++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一次走两个人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; <span class="number">4</span>; k++)   <span class="keyword">if</span> (bits[j] &amp;&amp; bits[k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = i - (<span class="number">1</span> &lt;&lt; j) - (<span class="number">1</span> &lt;&lt; k) + <span class="number">16</span>;</span><br><span class="line">                <span class="keyword">int</span> w = max(score[j],score[k]);</span><br><span class="line">                AddEdge(i, tmp, w, id++);</span><br><span class="line">                AddEdge(tmp, i, w, id++);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dijsktra(<span class="number">15</span>);</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, dis[<span class="number">16</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>教学管理系统web应用+SSM搭建记录</title>
    <url>//2020/InfoManageSystem-webApplication-setUp-record.html</url>
    <content><![CDATA[<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5.png"></p>
<p>从一份JavaWeb的作业开始不断改进。最终效果：实现了角色分工、信息增删改查、html+css界面，SSM整合。应该是我第一个用上了SSM的项目，边学边整合。<a id="more"></a></p>
<ul>
<li><input disabled type="checkbox"> 登录拦截器</li>
<li><input disabled type="checkbox"> 数据校验</li>
<li><input disabled type="checkbox"> 文件保存（下载）</li>
</ul>
<h1 id="项目初期"><a href="#项目初期" class="headerlink" title="项目初期"></a>项目初期</h1><p>刚准备开始做时的搭建计划：</p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/%E6%80%BB%E4%BD%93%E8%AE%A1%E5%88%92.png" alt="总体计划"></p>
<p>做了八天，其中整合界面（html+css）就花了一两天。从前端网站找的页面，整合过程中除了许许多多小问题，因为自己对于css和html也不是很熟悉，只处于看懂的水平，所以各种微调花了不少时间。</p>
<p>其中比较值得记录的应该就是抽取出来的<strong>分页功能</strong>：（后面MyBatis的PageHelper已经能够实现这个功能了）</p>
<h3 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h3><h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ol>
<li><p>使用IoC容器管理DataSource对象</p>
</li>
<li><p>依赖注入方式</p>
</li>
<li><p>@controller注解与tomcat管理servlet冲突</p>
<p>（这时还没有学SpringMVC，仍然用的servlet。）因此也不能加@Autowared标签。转而在WebUtils中实现从ioc容器中获取bean对象的方法。</p>
</li>
<li><p>开启事务</p>
</li>
</ol>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><ol>
<li>负责管理controller和视图层</li>
<li>配置中央分发器</li>
<li>改造所有servelt，以String的形式返回页面</li>
</ol>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><ol>
<li>去除DAO的实现类，直接为DAO接口写相应的sql语句</li>
<li>动态sql实现更加强大的功能</li>
<li>数据库字段与JavaBean属性的对应问题解决</li>
<li>MyBatis的代码生成器</li>
<li>PageHelper帮助实现分页功能</li>
</ol>
<p><strong>总结：</strong></p>
<ol>
<li><p>遇到的最大的问题？</p>
<p>因为这个项目功能很简单，虽然经常也会遇到配置错误等等各种小问题，但上网搜索后一般都能够解决。所以在其中遇到的最大的困难应该就是导包了，没有Maven真的很难，特别是不知道依赖些什么包，导入的过程中因为版本等原因错误不断。</p>
</li>
<li><p>如何解决这个问题的？</p>
<p>首先上网搜索，无果后找SSM的项目视频，看别人导了一些什么包，之后去找包。</p>
</li>
<li><p>第一次使用SSM的感受？</p>
<p>因为这个项目确实很小，对于这三个框架提供的便利性并没有太深的感受。但对于他们提供的功能有了初步的认识了。比如Spring的IoC、DI自动注入、动态代理和AOP思想；SpringMVC的ModelAndView、前端控制器、拦截器和后端验证、上传下载；MyBatis的简化的DAO开发、动态sql、延迟加载和缓存机制等等。</p>
</li>
</ol>
<h1 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h1><p><strong>管理员</strong>身份：</p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/1.jpg" alt="登录"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/2.jpg" alt="登陆失败"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/3.jpg" alt="登陆成功，进入主页"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/4.jpg" alt="点击课程信息"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/5.jpg" alt="实现分页"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/6.jpg" alt="点击添加课程"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/7.jpg" alt="点击修改"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/8.jpg" alt="点击删除"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/9.jpg" alt="点击学生信息"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/10.jpg" alt="修改"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/11.jpg" alt="点击查看成绩"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/12.jpg" alt="点击添加学生"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/13.jpg" alt="点击教师信息"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/14.jpg" alt="添加"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/15.jpg" alt="点击修改密码"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/16.jpg" alt="修改密码后跳至登陆界面"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/17.jpg" alt="退出后（之前有选择“记住我”）"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/18.jpg" alt="注销登录信息后"></p>
<p><strong>学生</strong>身份登录：</p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/19.jpg" alt="学生主页"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/20.jpg" alt="选课"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/21.jpg" alt="提示信息"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/22.jpg" alt="提示信息"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/23.jpg" alt="点击查看成绩"></p>
<p>（其余功能与管理员相同）</p>
<p><strong>教师</strong>身份登录：<br> <img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/24.jpg" alt="教师主页"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/25.jpg" alt="点击录入成绩"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/26.jpg" alt="选择某一学生"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/27.jpg" alt="点击录入"></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/28.jpg" alt="录入后"></p>
<p>（其余功能与管理员相同）</p>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="项目路径问题"><a href="#项目路径问题" class="headerlink" title="项目路径问题"></a>项目路径问题</h2><p>在Idea中修改Context（项目上下文路径）比较简单，只需要在Tomcat中配置一下就好了；但转到eclipse后，需要在server.xml中修改。</p>
<p>将path修改成你想要访问的项目根路径。</p>
<p>按下图修改后，访问路径变为 <a href="http://localhost:8080/">http://localhost:8080/</a></p>
<p><img src="/2020/InfoManageSystem-webApplication-setUp-record.htm/%E9%A1%B9%E7%9B%AE%E8%B7%AF%E5%BE%84%E4%BF%AE%E6%94%B9.png" alt="项目路径修改"></p>
<h2 id="bean对象无法自动注入"><a href="#bean对象无法自动注入" class="headerlink" title="bean对象无法自动注入"></a>bean对象无法自动注入</h2><p>我在某一个JavaBean中使用了@Autowired注解，却没有将该类加入ioc容器，自然就报空指针异常了。</p>
<h2 id="RequestMapping（“-hello”）-不起作用"><a href="#RequestMapping（“-hello”）-不起作用" class="headerlink" title="@RequestMapping（“/hello”） 不起作用"></a>@RequestMapping（“/hello”） 不起作用</h2>]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>树的遍历非递归算法及应用</title>
    <url>//2020/null.html</url>
    <content><![CDATA[<a id="more"></a>



<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>创建内部接口 Visitor ，通过传入方法来实现对遍历元素的定制操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> stop = <span class="keyword">false</span>; <span class="comment">// 标记停止位置，设置为true代表停止遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(TreeNode&lt;E&gt; node)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Visitor visitor = (node) -&gt; &#123;  <span class="comment">// 默认visitor，若没有传入则使用</span></span><br><span class="line">    System.out.print(node.element + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinaryTree&lt;Integer&gt; tree = <span class="keyword">new</span> BinaryTree&lt;&gt;();</span><br><span class="line">tree.preorder((node) -&gt; &#123;  </span><br><span class="line">    <span class="keyword">if</span>(node.element == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    node.element ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p>递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder1</span><span class="params">(Visitor visitor)</span></span>&#123;  <span class="comment">//设置为private，在public方法中有对visitor为空的判断</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span> || visitor.stop) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visitor.visit(root); <span class="comment">// 先对父节点进行操作</span></span><br><span class="line">    preorder1(root.left,visitor);</span><br><span class="line">    preorder1(root.right,visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder2</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;E&gt; node = root;</span><br><span class="line">    Stack&lt;TreeNode&lt;E&gt;&gt; stack = <span class="keyword">new</span> LinkedStack&lt;TreeNode&lt;E&gt;&gt;();</span><br><span class="line">    List&lt;TreeNode&lt;E&gt;&gt; visited = <span class="keyword">new</span> LinkedList&lt;TreeNode&lt;E&gt;&gt;(); <span class="comment">//记录访问过的节点</span></span><br><span class="line">    <span class="keyword">if</span>(visitor.stop) <span class="keyword">return</span>;</span><br><span class="line">    visitor.visit(node);</span><br><span class="line">    visited.add(node);</span><br><span class="line">    stack.push(node);</span><br><span class="line">    <span class="keyword">while</span>(visited.size() &lt; size) &#123;  <span class="comment">//size是tree的节点个数</span></span><br><span class="line">        <span class="keyword">if</span>(visitor.stop) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 来到这里，node已经被访问了，有left就立即访问，放入栈中，成为下一次访问的父节点（返回处）</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.left)) &#123;</span><br><span class="line">            visitor.visit(node.left);</span><br><span class="line">            visited.add(node.left);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// 有right就立即访问，放入栈中，成为下一次访问的父节点（返回处）</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.right)) &#123;</span><br><span class="line">            visitor.visit(node.right);</span><br><span class="line">            visited.add(node.right);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左右节点都没有了就弹栈，查看父节点的右节点</span></span><br><span class="line">            node = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder1</span><span class="params">(Visitor visitor)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span> || visitor.stop) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    inorder1(root.left,visitor);</span><br><span class="line">    <span class="keyword">if</span>(visitor.stop) <span class="keyword">return</span>;</span><br><span class="line">    visitor.visit(root);</span><br><span class="line">    inorder1(root.right,visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder2</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">    TreeNode&lt;E&gt; node = root;</span><br><span class="line">    List&lt;TreeNode&lt;E&gt;&gt; visited = <span class="keyword">new</span> LinkedList&lt;TreeNode&lt;E&gt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&lt;E&gt;&gt; stack = <span class="keyword">new</span> LinkedStack&lt;TreeNode&lt;E&gt;&gt;();</span><br><span class="line">    stack.push(node);</span><br><span class="line">    <span class="keyword">while</span>(node.left != <span class="keyword">null</span>) &#123; <span class="comment">//一直找到最左节点</span></span><br><span class="line">        stack.push(node.left);</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    node = stack.pop();</span><br><span class="line">    <span class="keyword">while</span>(visited.size() &lt; size) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.left)) &#123;</span><br><span class="line">            stack.push(node); <span class="comment">//有左节点才需要把该节点位置保存，否则直接访问</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(visitor.stop) <span class="keyword">return</span>;</span><br><span class="line">            visitor.visit(node);</span><br><span class="line">            visited.add(node);  <span class="comment">//先访问父节点，后判断是否有右节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.right)) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder1</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span> || visitor.stop) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    postorder1(root.left,visitor);</span><br><span class="line">    postorder1(root.right,visitor);</span><br><span class="line">    <span class="keyword">if</span>(visitor.stop) <span class="keyword">return</span>;</span><br><span class="line">    visitor.visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder2</span><span class="params">(TreeNode&lt;E&gt; root,Visitor visitor)</span></span>&#123;</span><br><span class="line">    TreeNode&lt;E&gt; node = root;</span><br><span class="line">    List&lt;TreeNode&lt;E&gt;&gt; visited = <span class="keyword">new</span> LinkedList&lt;TreeNode&lt;E&gt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&lt;E&gt;&gt; stack = <span class="keyword">new</span> LinkedStack&lt;TreeNode&lt;E&gt;&gt;();</span><br><span class="line">    stack.push(node);</span><br><span class="line">    <span class="keyword">while</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(node.left);</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    node = stack.pop();</span><br><span class="line">    <span class="keyword">while</span>(visited.size() &lt; size) &#123;</span><br><span class="line">        <span class="keyword">if</span>((node.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.left)) ||</span><br><span class="line">           (node.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.right))) &#123;  <span class="comment">//只有有需要访问的子节点</span></span><br><span class="line">            stack.push(node);  <span class="comment">//要访问子节点了，先把这个节点保存起来</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.left)) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(visitor.stop) <span class="keyword">return</span>;</span><br><span class="line">            visitor.visit(node);</span><br><span class="line">            visited.add(node); <span class="comment">//当左右节点访问完了，再访问父节点</span></span><br><span class="line">            node = stack.pop(); <span class="comment">//访问完这棵子树，弹栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelorder</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedQueue&lt;TreeNode&lt;E&gt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode&lt;E&gt; node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(visitor.stop) <span class="keyword">break</span>;</span><br><span class="line">        visitor.visit(node);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="计算树的高度"><a href="#计算树的高度" class="headerlink" title="计算树的高度"></a>计算树的高度</h2><h2 id="计算树的节点数量"><a href="#计算树的节点数量" class="headerlink" title="计算树的节点数量"></a>计算树的节点数量</h2><h2 id="复制树"><a href="#复制树" class="headerlink" title="复制树"></a>复制树</h2><p>非递归：(先序遍历)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BinaryTree&lt;E&gt; <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;E&gt; newRoot = <span class="keyword">new</span> TreeNode&lt;&gt;(root.element);</span><br><span class="line">    TreeNode&lt;E&gt; p = newRoot;</span><br><span class="line">    TreeNode&lt;E&gt; node = root;</span><br><span class="line">    List&lt;TreeNode&lt;E&gt;&gt; visited = <span class="keyword">new</span> LinkedList&lt;TreeNode&lt;E&gt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&lt;E&gt;&gt; stack = <span class="keyword">new</span> LinkedStack&lt;TreeNode&lt;E&gt;&gt;();</span><br><span class="line">    visited.add(newRoot);</span><br><span class="line">    <span class="keyword">while</span> (visited.size() != size) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.left)) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            TreeNode&lt;E&gt; newNode = <span class="keyword">new</span> TreeNode&lt;E&gt;(node.left.element);</span><br><span class="line">            visited.add(node.left);</span><br><span class="line">            p.left = newNode;</span><br><span class="line">            newNode.parent = p;</span><br><span class="line">            node = node.left;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.right)) &#123;</span><br><span class="line">            stack.push(node);  <span class="comment">// p只能按照parent的顺序返回，因此这里即使已经访问完这棵子树，仍需要将node压入栈中保存位置，否则node会与p不同步</span></span><br><span class="line">            TreeNode&lt;E&gt; newNode = <span class="keyword">new</span> TreeNode&lt;E&gt;(node.right.element);</span><br><span class="line">            visited.add(node.right);</span><br><span class="line">            p.right = newNode;</span><br><span class="line">            newNode.parent = p;</span><br><span class="line">            node = node.right;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTree&lt;E&gt; newTree = <span class="keyword">new</span> BinaryTree&lt;&gt;();</span><br><span class="line">    newTree.size = size;</span><br><span class="line">    newTree.root = newRoot;</span><br><span class="line">    <span class="keyword">return</span> newTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>我为什么选择找工作而不是读研</title>
    <url>//2021/why-I-choose-work.html</url>
    <content><![CDATA[<p>大一一年加大二半个学期过去，我的想法从”争取保研、实在不行就考研”的想法慢慢转到了”我真的适合读研吗”，但因为怕自己是因为”懒”而不想读研就迟迟没有决定好。终于，在寒假看了不少人的文章与分析权衡利弊后，我现在基本确定我会选择毕业后直接找工作，由此写写自己的心路历程。</p>
<a id="more"></a>



<h1 id="刚进大学：读研似乎是必经路？"><a href="#刚进大学：读研似乎是必经路？" class="headerlink" title="刚进大学：读研似乎是必经路？"></a>刚进大学：读研似乎是必经路？</h1><p>在高三一年的高强度复习后，我的成绩突飞猛进，再加上高考时的超常发挥，我成功取得了一个高分，最终进入了距家三千多公里外的哈尔滨工业大学的计算机系。</p>
<p>由于我高中时水平甚是一般，高一高二时甚至是级里的中下水平，我没有所谓学霸的光环，进入哈工大已经是我预料之外的惊喜，因此和周围一些因高考失利才进入的同学心态大有不同。按理说如此我应该就不会因为进入大学后排名与高中相比有落差而焦虑沮丧了吧？但非也，开学前那个假期的我，在开始的兴奋劲过去以后，焦虑瞬间袭来，我在网上找了不少关于大学学习和计算机专业的文章，越看越恐慌、越看越心里没底：数学不好、之前从没接触过编程的我能跟上吗?</p>
<p>也是在那时我看到许多”计算机专业的学生本科毕业之后必须要走读研这条路才能找到好工作”这样的观点，并深信不疑。我开始了解学校的保研要求：以学分绩从高到低可以保前20%左右，竞赛、优秀等可以加分。再一看学校通知：开学即有英语和体育的分班考试，核心课可以申请考试免修。因此我决定这个假期不能放松，得给我的大学生活开个好头。</p>
<p>我开始学微积分、C语言，同时不忘做英语、锻炼。但我的数学思维、记忆能力、基础都不强，自学的方法那时候也没找对，数学对于我来说真的是一场浩劫，有一次甚至因为做了几个小时题后还是不会新题，崩溃哭了。但为着能够开学后学得好些，还是坚持着。</p>
<p>正式开学后，免修考试没有及格，我选择进入了给假期学过的同学开的微积分提高班。但我高估了自己在微积分上的水平，提高班的每一节课我几乎都有大半的没听懂，只能通过课下花大量时间去补，因此我大一上学期花在自学新东西上的时间很少。</p>
<p>这么努力学习了一个学期，我的学分绩和排名都超出了我的预期，几乎全部课都在90以上（包括两门数学），排名也在10%。那时在学校身边的同学、老师都在谈论着保研、读研，好像所有人都在为着这个目标努力，回家父母亲戚都会问我成绩，帮我想着能不能保研。那时的我虽然感觉很累，但很开心，因为离保研又近了一点。</p>
<h1 id="疫情在家：开始发现除了课本学习之外的各种有趣技能"><a href="#疫情在家：开始发现除了课本学习之外的各种有趣技能" class="headerlink" title="疫情在家：开始发现除了课本学习之外的各种有趣技能"></a>疫情在家：开始发现除了课本学习之外的各种有趣技能</h1><p>在上学期学完C语言后，我开始渐渐体会到了编程的妙处，也会开始上网找一些小程序小游戏照着做，解决一个bug或者完整做出来的时候幸福感简直爆棚、恨不得告诉所有人我成功了。可能这种感觉对于那时的我来说真的是救命药：大一上的高压力学习让我情绪很不稳定，身体也出了一个蛮大的问题。我瞬间就爱上了那种感觉，开始找很多的编程相关的课程教程每天看。那时碰上疫情，大一下就没回学校，自己一个人在房间也能更专注。</p>
<p>那半年我学了Java、Javaweb、前端三件套、mysql、数据结构，了解了微信小程序开发、linux命令、SSM、Vue框架。收藏夹里的东西越来越多，我也越来越感觉这些东西学起来比数学物理要更吸引我。投入在基础课上的时间少了，回报自然也低了，我大一下的成绩退步了，排名也掉到了20%。</p>
<p>但那时的我开始思考：我一定要读研吗？为着保研花大力气在我不擅长的东西上面真的值当吗？我大一下学期的课程也是认真学了的，题也做了，但没有上学期刷得那么狠，几分的退步排名已相差很大。开级会时辅导员提到我们的学分绩时说相差零点零几就差了几名了，平均分都已经到了八十几。我不知道这成绩算不算”内卷”，但应该是在往这个方向发展了。</p>
<p>权衡读研还是工作就慢慢成为了我日常思考的重点，我的成绩我不能保证能够保持在前20%，竞赛方面我也很薄弱，参加可能很难拿奖，那么我保研的可能性不是特别大，我真的要选择花大量时间在争取保研上面吗？万一没有成功，几年的时间里没有多少用在提升自己真正的代码能力上，之后不是更难追上了吗？保研不成只能选择考研，但我知道自己没有准备高考的那股劲了，考研只怕又会是一场折磨。</p>
<p>当然我并不全是因为怕考试而不选择争取保研和准备考研，更大的原因是我对读研真的没有兴趣。之前我上过一门教新研究生如何使用文献阅读和管理工具的课，当时觉得新奇，便做了其中一个项目：针对一个细分的主题花连续的几个小时搜集文献、整理、阅读，写一篇报告。做完只觉天昏地暗、头发都掉了不知多少，从此开始畏惧看文献，特别是英文文献。想着读研生活必就是以此为常态了，便也开始畏惧读研。</p>
<h1 id="下定决心：我的理由"><a href="#下定决心：我的理由" class="headerlink" title="下定决心：我的理由"></a>下定决心：我的理由</h1><p>现在我基本已经确定我会选择本科毕业去找工作，我不能保证这对我以后的发展是最好的选择，毕竟会怎么变化谁也不知道，但我可以肯定我以后不会后悔这个决定。这其中有多方因素促使我坚定了不读研的想法。</p>
<ol>
<li>成绩不算特别好，保研可能悬，我也不想花太多时间在做题上面，考研当然是更加的”最好不要”。</li>
<li>和辅导员的聊天让我对本科校招的不自信没有那么强了，努努力至少工作是能找到的，底线在这就行。</li>
<li>读研后两年 or 三年后的我能学到什么呢？某个领域的皮毛吗？</li>
<li>说实话，大学生活被我过得和中学没有什么太大的变化，相比较于继续呆在学校，我现在迫切地想要开始一种新生活。</li>
<li>工作两三年后的我可能能力上有了很大的提升，当初没有得到的好工作可能还有机会。</li>
<li>家庭经济状况一般，我很想靠自己的力量给父母减负，况且赚到钱对于我来说也是一种莫大的鼓舞。</li>
</ol>
<p>每个人情况不同，选择自然也不同，我看了许多其他人关于”选择读研 or 工作”的文章和视频，最终选择了最适合我的那一个。无论如何，祝你我都有光明的前途。😀</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection及其实现源码</title>
    <url>//2020/Java-Collection-sourcecode.html</url>
    <content><![CDATA[<p><img src="/2020/Java-Collection-sourcecode.htm/Collection.jpg" alt="Collection"></p>
<a id="more"></a>



<p>各接口、抽象类作用：</p>
<ul>
<li><p><strong>RandomAccess</strong> 是一个标记接口，用于标记实现该接口的集合支持快速随机访问。</p>
</li>
<li><p><strong>Serializable</strong> 是一个标记接口，用于标记实现该接口的类可以序列化。</p>
</li>
<li><p><strong>Cloneable</strong> 是一个标记接口，用于标记实现该接口的类可以调用 clone 方法，否则会抛异常。</p>
</li>
<li><p><strong>Iterable</strong> 是一个遍历接口，内部提供了支持不同遍历方式的方法，比如顺序遍历迭代器、函数式的 foreach 遍历、并行遍历迭代器。</p>
</li>
<li><p><strong>Collection</strong> 是 java 集合体系的根接口，包含了通用的遍历、修改方法，例如 addAll、removeAll。</p>
</li>
<li><p><strong>AbstractCollection</strong> 是一个抽象类，重写了 Collection 中最基础的方法，减少具体集合类的实现成本，比如 contains、isEmpty、toArray，iterator，但是 add 等需要具体集合类自我实现。</p>
</li>
<li><p><strong>List</strong> 是 java 有序集合的基础接口，除了 Collection 的方法，还有支持倒序遍历的 listIterator 方法、子列表 subList 方法，另外重写 spliterator 方法的实现。</p>
</li>
<li><p><strong>AbstractList</strong> 是一个抽象类，重写了 List 的大部分方法，作用跟 AbstractCollection 类似。</p>
</li>
</ul>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 是一个接口，定义一组有序、可重复的元素集合。</p>
<p><img src="/2020/Java-Collection-sourcecode.htm/List%E6%96%B9%E6%B3%95.jpg" alt="List方法"></p>
<p>较之 Collection，List 还添加了以下操作方法</p>
<ul>
<li>位置相关：List 的元素是有序的，因此有get(index)、set(index,object)、add(index,object)、remove(index) 方法。</li>
<li>搜索：indexOf()，lastIndexOf();</li>
<li>迭代：使用 Iterator 的功能板迭代器</li>
<li>范围性操作：使用 subList 方法对 list 进行任意范围操作。</li>
</ul>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><h3 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h3><p>是List的抽象实现类，继承自 AbstractCollection 类。整个类的设计类似于AbstractCollection,实现了大多数方法，抽象了对于需要根据数据操作的方法。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 是我们最常用的一个类，它具有如下特点：</p>
<ul>
<li>可以动态扩容</li>
<li>有序</li>
<li>元素可以为 null</li>
<li>效率高<ul>
<li>查找操作的时间复杂度是 O(1)</li>
<li>增删操作的时间复杂度是 O(n)</li>
<li>其他操作基本也都是 O(n)</li>
</ul>
</li>
<li>占用空间少，相比 LinkedList，不用占用额外空间维护表结构</li>
</ul>
<p><img src="/2020/Java-Collection-sourcecode.htm/ArrayList.jpg" alt="ArrayList"></p>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ensureCapacityInternal(<span class="keyword">this</span>.size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.size++] = var1;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//判断是否越界</span></span><br><span class="line">    modCount++;<span class="comment">//修改modeCount 因为结构改变了</span></span><br><span class="line">    E oldValue = elementData(index);<span class="comment">//读出要删除的值</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);<span class="comment">//用复制 覆盖数组数据</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work  //置空原尾部数据 不再强引用， 可以GC掉</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据下标从数组取值 并强转</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除该元素在数组中第一次出现的位置上的数据。 如果有该元素返回true，如果false。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);<span class="comment">//根据index删除元素</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不会越界 不用判断 ，也不需要取出该元素。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//修改modCount</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//计算要移动的元素数量</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);<span class="comment">//以复制覆盖元素 完成删除</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work  //置空 不再强引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);<span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量移动</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;<span class="comment">//w 代表批量删除后 数组还剩多少元素</span></span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//高效的保存两个集合公有元素的算法</span></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement) <span class="comment">// 如果 c里不包含当前下标元素， </span></span><br><span class="line">                elementData[w++] = elementData[r];<span class="comment">//则保留</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123; <span class="comment">//出现异常会导致 r !=size , 则将出现异常处后面的数据全部复制覆盖到数组里。</span></span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;<span class="comment">//修改 w数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;<span class="comment">//置空数组后面的元素</span></span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;<span class="comment">//修改modCount</span></span><br><span class="line">            size = w;<span class="comment">// 修改size</span></span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==注==：增删改查中， 增导致扩容，则会修改modCount，删也一定会修改。 改和查一定不会修改modCount。</p>
<h4 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通的for循环寻找值，只不过会根据目标对象是否为null分别循环查找。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通的for循环寻找值，只不过会根据目标对象是否为null分别循环查找。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return //默认是0</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such  //上一次返回的元素 (删除的标志位)</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount; <span class="comment">//用于判断集合是否修改过结构的 标志</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;<span class="comment">//游标是否移动至尾部</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)<span class="comment">//判断是否越界</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)<span class="comment">//再次判断是否越界，在 我们这里的操作时，有异步线程修改了List</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;<span class="comment">//游标+1</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];<span class="comment">//返回元素 ，并设置上一次返回的元素的下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;<span class="comment">//remove 掉 上一次next的元素</span></span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)<span class="comment">//先判断是否next过</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();<span class="comment">//判断是否修改过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);<span class="comment">//删除元素 remove方法内会修改 modCount 所以后面要更新Iterator里的这个标志值</span></span><br><span class="line">            cursor = lastRet; <span class="comment">//要删除的游标</span></span><br><span class="line">            lastRet = -<span class="number">1</span>; <span class="comment">//不能重复删除 所以修改删除的标志位</span></span><br><span class="line">            expectedModCount = modCount;<span class="comment">//更新 判断集合是否修改的标志，</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断是否修改过了List的结构，如果有修改，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>ArrayList 的序列化没有直接序列化 elementData，而是根据 size 序列化包含的元素，忽略数组中的其它位置，提高效率并节省空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// fail-fast，后续判断是否有并发处理</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 序列化没有标记为 static、transient 的字段，包括 size 等。</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有意义，可以忽略</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="comment">// ArrayList 被并发处理，发生结构性修改</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化没有标记为 static、transient 的字段，包括 size 等</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以忽略，跟 writeObject 里面的方法对应</span></span><br><span class="line">    s.readInt(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组扩容</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 反序列化元素并填充到数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 继承自 AbstractSequentialList。AbstractSequentialList 又继承自AbstractList，并且基于 iterator 实现了默认增删改查操作。</p>
<p><img src="/2020/Java-Collection-sourcecode.htm/LinkedList.jpg" alt="LinkedList"></p>
<p>文末附完整源码。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>线程安全的 ArrayList。Vector 和 ArrayList 一样都继承自 AbstractList，除了 Vector 的方法上多了个 synchronized 外，代码都是一样的。效率相对会比较低。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack 继承自Vector，也是一个线程安全的集合。基于数组实现栈结构集合。</p>
<p><img src="/2020/Java-Collection-sourcecode.htm/Stack.jpg" alt="Stack"></p>
<p>LinkedList 完整源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LinkedList的元素个数：</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LinkedList的头结点：Node内部类</span></span><br><span class="line">    <span class="keyword">transient</span> java.util.LinkedList.Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LinkedList尾结点：Node内部类</span></span><br><span class="line">    <span class="keyword">transient</span> java.util.LinkedList.Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空实现：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用添加方法：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LinkedList添加首结点 first：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//first节点插入新元素：addFirst()调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头结点：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">//创建一个新节点，并指向头结点f：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; newNode = <span class="keyword">new</span> java.util.LinkedList.Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        <span class="comment">//将新节点赋值给头几点：</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">//如果头节点为null，则是第一个元素插入，将新节点也设置为尾结点；</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//将之前的头结点的前指针指向新的结点：</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        <span class="comment">//长度+1</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//操作数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素：添加到最后一个结点；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加最后一个结点 last：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last节点插入新元素：addLast()调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将尾结点赋值个体L:</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">//创建新的结点，将新节点的前指针指向l:</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; newNode = <span class="keyword">new</span> java.util.LinkedList.Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//新节点置为尾结点：</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="comment">//如果尾结点l为null：则是空集合新插入</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//头结点也置为 新节点：</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//l节点的后指针指向新节点：</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        <span class="comment">//长度+1</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//操作数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向对应角标添加元素：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查传入的角标 是否正确：</span></span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="comment">//如果插入角标==集合长度，则插入到集合的最后面：</span></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//插入到对应角标的位置：获取此角标下的元素先</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在succ前插入 新元素e：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, java.util.LinkedList.Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取被插入元素succ的前指针元素：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="comment">//创建新增元素节点，前指针 和 后指针分别指向对应元素：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; newNode = <span class="keyword">new</span> java.util.LinkedList.Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="comment">//succ的前指针元素可能为null，为null的话说明succ是头结点，则把新建立的结点置为头结点：</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//succ前指针不为null，则将前指针的结点的后指针指向新节点：</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        <span class="comment">//长度+1</span></span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//操作数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除首个结点：如果集合还没有元素则报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">//首节点为null，则抛出异常；</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除LinkedList的头结点：removeFirst()方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(java.util.LinkedList.Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//f为头结点：获取头结点元素E</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="comment">//获取头结点的尾指针结点：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; next = f.next;</span><br><span class="line">        <span class="comment">//将头结点元素置为null：</span></span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//头结点尾指针置为null：</span></span><br><span class="line">        f.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将头结点的尾指针指向的结点next置为first</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="comment">//尾指针指向结点next为null的话，就将尾结点也置为null（LinkedList中只有一个元素时出现）</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//将尾指针指向结点next的 前指针置为null；</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 长度减1</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">//操作数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//返回被删除的元素：</span></span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除最后一个结点：如果集合还没有元素则报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取最后一个结点：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">//删除尾结点：</span></span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除LinkedList的尾结点：removeLast()方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(java.util.LinkedList.Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除LinkedList中的元素，可以删除为null的元素，逐个遍历LinkedList的元素；</span></span><br><span class="line">    <span class="comment">//重复元素只删除第一个：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果删除元素为null：</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果删除元素不为null：</span></span><br><span class="line">            <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除LinkedList结点：remove()方法中调用</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(java.util.LinkedList.Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取被删除结点的元素E：</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="comment">//获取被删除元素的后指针结点：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="comment">//获取被删除元素的前指针结点：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被删除结点的 前结点为null的话：</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将后指针指向的结点置为头结点</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//前置结点的  尾结点指向被删除的next结点；</span></span><br><span class="line">            prev.next = next;</span><br><span class="line">            <span class="comment">//被删除结点前指针置为null:</span></span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对尾结点同样处理：</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到首个结点：集合没有元素报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取first结点：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到最后一个结点：集合没有元素报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取last结点：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断obj 是否存在：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LinkedList长度：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加集合：从最后size所在的index开始：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LinkedList添加集合：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查角标是否正确：</span></span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        java.util.LinkedList.Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            E e = (E) o;</span><br><span class="line">            java.util.LinkedList.Node&lt;E&gt; newNode = <span class="keyword">new</span> java.util.LinkedList.Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空LinkedList：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历LinedList集合：</span></span><br><span class="line">        <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="comment">//将每个结点的前指针 尾指针  元素都置为null：</span></span><br><span class="line">            java.util.LinkedList.Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="keyword">null</span>;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头尾结点 都置为null：</span></span><br><span class="line">        first = last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//长度置为0</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//操作数+1：</span></span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取相应角标的元素：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查角标是否正确：</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">//获取角标所属结点的 元素值：</span></span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置对应角标的元素：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        java.util.LinkedList.Node&lt;E&gt; x = node(index);</span><br><span class="line">        E oldVal = x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除对应角标的元素：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对应角标所属于的结点：</span></span><br><span class="line">    java.util.LinkedList.<span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//位运算：如果位置索引小于列表长度的一半，从前面开始遍历；否则，从后面开始遍历；</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            java.util.LinkedList.Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="comment">//从头结点开始遍历：遍历的长度就是index的长度，获取对应的index的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从集合尾结点遍历：</span></span><br><span class="line">            java.util.LinkedList.Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="comment">//同样道理：</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左移相当于*2，只是要注意边界问题。如char a = 65； a&lt;&lt;1 按照*2来算为130;</span></span><br><span class="line">    <span class="comment">// 但有符号char的取值范围-128~127，已经越界，多超出了3个数值，</span></span><br><span class="line">    <span class="comment">// 所以从-128算起的第三个数值-126才是a&lt;&lt;1的正确结果。</span></span><br><span class="line">    <span class="comment">//而右移相当于除以2，只是要注意移位比较多的时候结果会趋近去一个非常小的数，如上面结果中的-1，0。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断传入的index是否正确：</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查传入的角标 是否正确：</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//必须大于0 ，并且不能大于当前size：</span></span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第一个元素，不存在则抛异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，获取第一个元素，不出队列，只是获取</span></span><br><span class="line">    <span class="comment">// 队列先进先出；不存在不抛异常，返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取头结点：</span></span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">//存在获取头结点元素，不存在返回null</span></span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，并移除第一个元素；不存在不抛异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队（删除第一个结点），如果不存在会抛出异常而不是返回null，存在的话会返回值并移除这个元素（节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队(插入最后一个结点)从最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队（插入头结点），始终返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队（插入尾结点），始终返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队（从前端），获得第一个元素，不存在会返回null，不会删除元素（节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队（从后端），获得最后一个元素，不存在会返回null，不会删除元素（节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队（从前端），获得第一个元素，不存在会返回null，会删除元素（节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队（从后端），获得最后一个元素，不存在会返回null，会删除元素（节点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> java.util.LinkedList.Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈，从前面添加  栈 后进先出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈，返回栈顶元素，从前面移除（会删除）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的数据结构，包含前后节点的引用和当前节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//结点元素：</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">//结点后指针</span></span><br><span class="line">        java.util.LinkedList.Node&lt;E&gt; next;</span><br><span class="line">        <span class="comment">//结点前指针</span></span><br><span class="line">        java.util.LinkedList.Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(java.util.LinkedList.Node&lt;E&gt; prev, E element, java.util.LinkedList.Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//迭代器：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> java.util.LinkedList.ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> java.util.LinkedList.Node&lt;E&gt; lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> java.util.LinkedList.Node&lt;E&gt; next;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">            nextIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">            nextIndex--;</span><br><span class="line">            <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">            java.util.LinkedList.Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">            unlink(lastReturned);</span><br><span class="line">            <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">                next = lastNext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextIndex--;</span><br><span class="line">            lastReturned = <span class="keyword">null</span>;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned.item = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            lastReturned = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                linkLast(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                linkBefore(e, next);</span><br><span class="line">            nextIndex++;</span><br><span class="line">            expectedModCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> java.util.<span class="function">LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (java.util.LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        java.util.LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line">        clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">        clone.size = <span class="number">0</span>;</span><br><span class="line">        clone.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            clone.add(x.item);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                    a.getClass().getComponentType(), size);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Object[] result = a;</span><br><span class="line">        <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">876323262645176354L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (java.util.LinkedList.Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">            s.writeObject(x.item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            linkLast((E)s.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络核心知识一网打尽</title>
    <url>//2020/null.html</url>
    <content><![CDATA[<p>转自公众号：<a href="https://mp.weixin.qq.com/s/6ju4j_ffLuOBuoO53ZhcOA">JavaGuide:大二逃课总结1.2w字的计算机网络知识</a> <a id="more"></a></p>
<h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h2><h3 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1. 基本术语"></a>1.1. 基本术语</h3><ol>
<li><strong>结点 （node）</strong> ：网络中的结点可以是计算机，集线器，交换机或路由器等。</li>
<li><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li>
<li><strong>主机（host）</strong> ：连接在因特网上的计算机。</li>
<li><strong>ISP（Internet Service Provider）</strong> ：因特网服务提供者（提供商）。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KyPrXgjoZp17VBfyxqcE8KTEyFqC9ZvMBlnT5nKpd29fmBvbyX0QFKA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="ISP (Internet Service Provider) Definition"></p>
<ol>
<li><strong>IXP（Internet eXchange Point）</strong> ：互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40Ko5p7DwqbmNKFGp6Tfib6HmshXw22mKoXMagJuKcRl7fqnVWRf6q5lGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="IXP Traffic Levels During the Stratos Skydive — RIPE Labs"></p>
<p><a href="https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</a></p>
<ol>
<li><strong>RFC(Request For Comments)</strong> ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li>
<li><strong>广域网 WAN（Wide Area Network）</strong> ：任务是通过长距离运送主机发送的数据。</li>
<li><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li>
<li><strong>局域网 LAN（Local Area Network）</strong> ：学校或企业大多拥有多个互连的局域网。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KrcbeiaicrHWViab1Y1CpIL7HCRPkDU9krlC4LLNE7ZFd1OichDpTHpAWdg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="WMAN | Red de área metropolitana, Redes informaticas, Par trenzado">MAN &amp; </p>
<p><a href="http://conexionesmanwman.blogspot.com/">http://conexionesmanwman.blogspot.com/</a></p>
<ol>
<li><strong>个人区域网 PAN（Personal Area Network）</strong> ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40K17hIicYcjUMEWOXggkLW94Jyj7iayq3yEXnQJ42JYD0sawosic7Olz8vA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Advantages and disadvantages of personal area network (PAN) - IT Release"></p>
<p><a href="https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</a></p>
<ol>
<li><strong>分组（packet ）</strong> ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</li>
<li><strong>存储转发（store and forward ）</strong> ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KAGYPOOZYnccAPtoIe5wwSaTP9vlaJxgyLyISqBtjzkoLMWtB7miabrQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1"></p>
<ol>
<li><strong>带宽（bandwidth）</strong> ：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li>
<li><strong>吞吐量（throughput ）</strong> ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li>
</ol>
<h3 id="1-2-重要知识点总结"><a href="#1-2-重要知识点总结" class="headerlink" title="1.2. 重要知识点总结"></a>1.2. 重要知识点总结</h3><ol>
<li><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li>
<li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li>
<li>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li>
<li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li>
<li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li>
<li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li>
<li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li>
<li><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li>
<li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li>
<li><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40Kfsz72GZ1EcdaK10TEDmLicfWKA44icf6qaHtiaHfbPw2FQnaj8Ia9TMaw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p>
<h2 id="2-物理层（Physical-Layer）"><a href="#2-物理层（Physical-Layer）" class="headerlink" title="2. 物理层（Physical Layer）"></a>2. 物理层（Physical Layer）</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KNaLqxZxFpZ39VMbFIhIco1KNmP32LgXonpxmyaCIiaicNqibF2pwqovRg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="物理层"></p>
<h3 id="2-1-基本术语"><a href="#2-1-基本术语" class="headerlink" title="2.1. 基本术语"></a>2.1. 基本术语</h3><ol>
<li><strong>数据（data）</strong> :运送消息的实体。</li>
<li><strong>信号（signal）</strong> ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li>
<li><strong>码元（ code）</strong> ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li>
<li><strong>单工（simplex ）</strong> : 只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>半双工（half duplex ）</strong> ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li><strong>全双工（full duplex）</strong> : 通信的双方可以同时发送和接收信息。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40Kic4S5U3DHOIqEJZPHpstnia2tKS0WEeLiaGJKfaJnbicicXDtvVoBianfAYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<ol>
<li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KohbQkoq2McFba8v1vVys8JHhycQvNqDBn9T2kksRcIwqibtwGlK41dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<ol>
<li><strong>奈氏准则</strong> : 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li>
<li><strong>香农定理</strong> ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li>
<li><strong>基带信号（baseband signal）</strong> : 来自信源的信号。指没有经过调制的数字信号或模拟信号。</li>
<li><strong>带通（频带）信号（bandpass signal）</strong> ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li>
<li><strong>调制（modulation ）</strong> : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li>
<li><strong>信噪比（signal-to-noise ratio ）</strong> : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li>
<li><strong>信道复用（channel multiplexing ）</strong> ：指多个用户共享同一个信道。（并不一定是同时）。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KbnVTuNkLQX0B1mYiamxa2pA4WL5mxiakq2oBsXYzXjac0kofNmg44L3A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="信道复用技术"></p>
<ol>
<li><strong>比特率（bit rate ）</strong> ：单位时间（每秒）内传送的比特数。</li>
<li><strong>波特率（baud rate）</strong> ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li>
<li><strong>复用（multiplexing）</strong> ：共享信道的方法。</li>
<li><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong> ：非对称数字用户线。</li>
<li><strong>光纤同轴混合网（HFC 网）</strong> :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li>
</ol>
<h3 id="2-2-重要知识点总结"><a href="#2-2-重要知识点总结" class="headerlink" title="2.2. 重要知识点总结"></a>2.2. 重要知识点总结</h3><ol>
<li><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li>
<li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>
<li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</strong></li>
<li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>
<li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>
<li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>
<li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>
<li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>
<li>了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li>
</ol>
<h3 id="2-3-补充"><a href="#2-3-补充" class="headerlink" title="2.3. 补充"></a>2.3. 补充</h3><h4 id="2-3-1-物理层主要做啥？"><a href="#2-3-1-物理层主要做啥？" class="headerlink" title="2.3.1. 物理层主要做啥？"></a>2.3.1. 物理层主要做啥？</h4><p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</p>
<p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>
<h4 id="2-3-2-几种常用的信道复用技术"><a href="#2-3-2-几种常用的信道复用技术" class="headerlink" title="2.3.2. 几种常用的信道复用技术"></a>2.3.2. 几种常用的信道复用技术</h4><ol>
<li><strong>频分复用(FDM)</strong> ：所有用户在同样的时间占用不同的带宽资源。</li>
<li><strong>时分复用（TDM）</strong> ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li>
<li><strong>统计时分复用 (Statistic TDM)</strong> ：改进的时分复用，能够明显提高信道的利用率。</li>
<li><strong>码分复用(CDM)</strong> ：用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>
<li><strong>波分复用( WDM)</strong> ：波分复用就是光的频分复用。</li>
</ol>
<h4 id="2-3-3-几种常用的宽带接入技术，主要是-ADSL-和-FTTx"><a href="#2-3-3-几种常用的宽带接入技术，主要是-ADSL-和-FTTx" class="headerlink" title="2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx"></a>2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p>
<h2 id="3-数据链路层（Data-Link-Layer）"><a href="#3-数据链路层（Data-Link-Layer）" class="headerlink" title="3. 数据链路层（Data Link Layer）"></a>3. 数据链路层（Data Link Layer）</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KyfdFTVYKazEFHWlq5TjQ1nrXKNibicB8Rnl0CWpxjwdZMy7NQ3BicA5Uw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="数据链路层"></p>
<h3 id="3-1-基本术语"><a href="#3-1-基本术语" class="headerlink" title="3.1. 基本术语"></a>3.1. 基本术语</h3><ol>
<li><p><strong>链路（link）</strong> ：一个结点到相邻结点的一段物理链路。</p>
</li>
<li><p><strong>数据链路（data link）</strong> ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</p>
</li>
<li><p><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong> ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</p>
</li>
<li><p><strong>帧（frame）</strong> ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</p>
</li>
<li><p><strong>MTU（Maximum Transfer Uint ）</strong> ：最大传送单元。帧的数据部分的的长度上限。</p>
</li>
<li><p><strong>误码率 BER（Bit Error Rate ）</strong> ：在一段时间内，传输错误的比特占所传输比特总数的比率。</p>
</li>
<li><p><strong>PPP（Point-to-Point Protocol ）</strong> ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KcgHcrb0eBKhQpqeYh333QnQWqv9iaicmsibRoWNmZJjXLmaQamIpUicymw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
</li>
<li><p><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong> ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。</p>
</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KbbMOaYPic0dt4kjLMVrZicwRGkAlcQZvH84PdvKAeBecXh0u0dkzAhibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="ARP (Address Resolution Protocol) explained"></p>
<ol>
<li><strong>网桥（bridge）</strong> ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li>
<li><strong>交换机（switch ）</strong> ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li>
</ol>
<h3 id="3-2-重要知识点总结"><a href="#3-2-重要知识点总结" class="headerlink" title="3.2. 重要知识点总结"></a>3.2. 重要知识点总结</h3><ol>
<li>链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>
<li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>
<li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>
<li><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li>
<li><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>
<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>
<li><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li>
<li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li>
<li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>
<li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</li>
<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>
<li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>
</ol>
<h3 id="3-3-补充"><a href="#3-3-补充" class="headerlink" title="3.3. 补充"></a>3.3. 补充</h3><ol>
<li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li>
<li>数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li>
<li>以太网的 MAC 层硬件地址</li>
<li>适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li>
</ol>
<h2 id="4-网络层（Network-Layer）"><a href="#4-网络层（Network-Layer）" class="headerlink" title="4. 网络层（Network Layer）"></a>4. 网络层（Network Layer）</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KheCDa24wZ5XBmYdgegDSbnHUib2cFcYr6CEYVyzzMNLJFYzttzFCzIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="网络层"></p>
<h3 id="4-1-基本术语"><a href="#4-1-基本术语" class="headerlink" title="4.1. 基本术语"></a>4.1. 基本术语</h3><ol>
<li><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li>
<li><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li>
<li><strong>ICMP（Internet Control Message Protocol ）</strong> ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li>
<li><strong>子网掩码（subnet mask ）</strong> ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li>
<li>**CIDR（ Classless Inter-Domain Routing ） **：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li>
<li><strong>默认路由（default route）</strong> ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li>
<li><strong>路由选择算法（Virtual Circuit）</strong> ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li>
</ol>
<h3 id="4-2-重要知识点总结"><a href="#4-2-重要知识点总结" class="headerlink" title="4.2. 重要知识点总结"></a>4.2. 重要知识点总结</h3><ol>
<li><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</strong></li>
<li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>
<li>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li>
<li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>
<li><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送 ARP 请求分组</strong></li>
<li>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li>
<li>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种 ICMP 差错报告报文和 ICMP 询问报文。</li>
<li><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li>
<li><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li>
<li>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>
</ol>
<h2 id="5-传输层（Transport-Layer）"><a href="#5-传输层（Transport-Layer）" class="headerlink" title="5. 传输层（Transport Layer）"></a>5. 传输层（Transport Layer）</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KoHBD0X9EMw9t3oPz1tDEHiaSqibTibJNfOicXfEZiaib61WSMLuP4smoiaB6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="传输层"></p>
<h3 id="5-1-基本术语"><a href="#5-1-基本术语" class="headerlink" title="5.1. 基本术语"></a>5.1. 基本术语</h3><ol>
<li><strong>进程（process）</strong> ：指计算机中正在运行的程序实体。</li>
<li><strong>应用进程互相通信</strong> ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li>
<li><strong>传输层的复用与分用</strong> ：复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li>
<li><strong>TCP（Transmission Control Protocol）</strong> ：传输控制协议。</li>
<li><strong>UDP（User Datagram Protocol）</strong> ：用户数据报协议。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40K5WSJtMImibp4CUwlNA0rsoSUrYe0DsBwWic3FiaYKjO9meXcB2tT0qiblQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="TCP和UDP"></p>
<ol>
<li>**端口（port） ** ：端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li>
<li><strong>停止等待协议（stop-and-wait）</strong> ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li>
<li><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>
<li><strong>拥塞控制</strong> ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>
</ol>
<h3 id="5-2-重要知识点总结"><a href="#5-2-重要知识点总结" class="headerlink" title="5.2. 重要知识点总结"></a>5.2. 重要知识点总结</h3><ol>
<li><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li>
<li><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li>
<li>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li>
<li><strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>
<li>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li>
<li>运输层的端口号分为服务器端使用的端口号（0<del>1023 指派给熟知端口，1024</del>49151 是登记端口号）和客户端暂时使用的端口号（49152~65535）</li>
<li><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li>
<li><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li>
<li><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一被通信两端的两个端点所确定。</strong></li>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>
<li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>
<li>TCP 报文段的前 20 个字节是固定的，后面有 4n 字节是根据需要增加的选项。因此，TCP 首部的最小长度是 20 字节。</li>
<li><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li>
<li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li>
<li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>
<li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li>
<li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li>
</ol>
<h3 id="5-3-补充（重要）"><a href="#5-3-补充（重要）" class="headerlink" title="5.3. 补充（重要）"></a>5.3. 补充（重要）</h3><p>以下知识点需要重点关注：</p>
<ol>
<li>端口和套接字的意义</li>
<li>UDP 和 TCP 的区别以及两者的应用场景</li>
<li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li>
<li>TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li>
<li>TCP 的三次握手，四次挥手机制</li>
</ol>
<h2 id="6-应用层（Application-Layer）"><a href="#6-应用层（Application-Layer）" class="headerlink" title="6. 应用层（Application Layer）"></a>6. 应用层（Application Layer）</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40Ke33HT18JEZTyPFrStiaMHdWs7a7T07CIbdLryJoCJMZ5f83Ltug9Mlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="应用层"></p>
<h3 id="6-1-基本术语"><a href="#6-1-基本术语" class="headerlink" title="6.1. 基本术语"></a>6.1. 基本术语</h3><ol>
<li><strong>域名系统（DNS）</strong> ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KGmT3bbwRxUcDUnW3FGTuJyDFJeQoztiaqdafsrxVr6QmmcU6UnngIEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><a href="https://www.seobility.net/en/wiki/HTTP_headers">https://www.seobility.net/en/wiki/HTTP_headers</a></p>
<ol>
<li><strong>文件传输协议（FTP）</strong> ：FTP 是 File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KoyZl04PDhEBgdCSWUVej9SCYvnJEufWlZBIwOAtm5Jlzs54ficyU5WA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="FTP工作过程"></p>
<ol>
<li><strong>简单文件传输协议（TFTP）</strong> ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li>
<li><strong>远程终端协议（TELENET）</strong> ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li>
<li><strong>万维网（WWW）</strong> ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li>
<li><strong>万维网的大致工作工程：</strong></li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KtdIowP6M0tWZhaRlF8icddPztoaDnXhGDJXP0Q13e3lG0wmepfU7AQQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="万维网的大致工作工程"></p>
<ol>
<li><strong>统一资源定位符（URL）</strong> ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li>
<li><strong>超文本传输协议（HTTP）</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li>
</ol>
<p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Txpk4narOnyI7xL1Im2X40K5y5tH02HtyI4D0icvNjlcoH9qxOiaMibjdgkVu8YB6ZXl7BoslFic7l5sQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<ol>
<li><strong>代理服务器（Proxy Server）</strong> ：代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li>
<li><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KibGIaIUian9kArCrxV65TBdbWeY7w3rgtlroia7KhtRbic3e8GlyYsZHbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="一个电子邮件被发送的过程"></p>
<p><a href="https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/</a></p>
<ol>
<li><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Txpk4narOnyI7xL1Im2X40KAdo3NwVkz5KOWB2Pht1bVO74ltib8C29xqHiabCYJiaUIJehjLsVI4r9w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="搜索引擎"></p>
<ol>
<li><strong>垂直搜索引擎</strong> ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</li>
<li><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</li>
<li><strong>目录索引</strong> ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</li>
</ol>
<h3 id="6-2-重要知识点总结"><a href="#6-2-重要知识点总结" class="headerlink" title="6.2. 重要知识点总结"></a>6.2. 重要知识点总结</h3><ol>
<li>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li>
<li>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li>
<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li>
<li>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li>
</ol>
<h3 id="6-3-补充（重要）"><a href="#6-3-补充（重要）" class="headerlink" title="6.3. 补充（重要）"></a>6.3. 补充（重要）</h3><p>以下知识点需要重点关注：</p>
<ol>
<li>应用层的常见协议（重点关注 HTTP 协议）</li>
<li>域名系统-从域名解析出 IP 地址</li>
<li>访问一个网站大致的过程</li>
<li>系统调用和应用编程接口概念</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>其实吧，现在还没什么好写。</p>
]]></content>
  </entry>
  <entry>
    <title>404</title>
    <url>/404/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>algorithms</title>
    <url>/algorithms/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>一些分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<h1 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h1>]]></content>
  </entry>
  <entry>
    <title>archives</title>
    <url>/archives/index.html</url>
    <content><![CDATA[<h1 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h1>]]></content>
  </entry>
  <entry>
    <title>life</title>
    <url>/life/index.html</url>
    <content><![CDATA[<h1 id="life"><a href="#life" class="headerlink" title="life"></a>life</h1>]]></content>
  </entry>
  <entry>
    <title>书籍电影</title>
    <url>/share/index.html</url>
    <content><![CDATA[<div class="tabs" id="share"><ul class="nav-tabs"><li class="tab active"><a href="#share-1"><i class="fas fa-book"></i>书单</a></li><li class="tab"><a href="#share-2"><i class="fas fa-video"></i>纪录片</a></li></ul><div class="tab-content"><div class="tab-pane active" id="share-1"><ul>
<li><p><a href="https://book.douban.com/subject/25864000/"><strong>台湾这些年所知道的祖国</strong></a>. 廖信忠<br>作者的系列作品了，不过说实话没有最初的《我们台湾这些年》好看。</p>
</li>
<li><p><a href="https://book.douban.com/subject/4113090/"><strong>我们台湾这些年</strong></a>. 廖信忠<br>一个个小人物的故事构成了台湾社会发展的方方面面，一本书或许不能帮助我们认识了解这个宝岛的过往，但是可以带给一个我们更真切的台湾。</p>
</li>
<li><p><a href="https://book.douban.com/subject/2004652/"><strong>目击中国100年</strong></a>. 成勇<br>十分用心编写的一本书，或者更准确说是画册。用照片的方式展现有照片记录以来中国20世纪的诸多历史瞬间，让我们得以了解更生动立体的近现代中国。</p>
</li>
<li><p><a href="https://book.douban.com/subject/20424526/"><strong>邓小平时代</strong></a>. 傅高义<br>资料翔实，叙述详尽，向我们展现了改革开放前后那个瞬息万变的历史时期。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26847432/"><strong>為了活下去：脫北女孩朴研美</strong></a>. 朴研美<br>台湾旅游时候买回来的书，对于描述作者个人的经历确实比较同情，但是后面对于中国做法的看法以及对于基督教的理解还是不太认同的。特别是韩国传教士的问题，或许对作者这样的人来说是帮助，但是在中国的疯狂传教其实是很大隐患。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26899255/"><strong>进击的局座</strong></a>. 张召忠<br>局座的书，看中名气买的电子书，语言很朴实很真诚，不过不是我喜欢的话题和风格。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26285840/"><strong>漫画世界系列3：漫画德国</strong></a>. 李元馥<br>高中时候班主任推荐的丛书，从漫画的角度了解各国的社会人文历史，也是很有趣味的，还希望能够把这套书都读一遍。</p>
</li>
<li><p><a href="https://book.douban.com/subject/1526244/"><strong>科学探索者 · 天文学</strong></a>. 帕迪利亚<br>小时候的天文学科普启蒙书之一，里面的好多小实验很有趣味，讲解的一些知识点现在都有印象。</p>
</li>
<li><p><a href="https://book.douban.com/subject/1137118/"><strong>放飞神舟</strong></a>. 石磊<br>我对中国载人航天的最初了解就是这本书带给我的，放飞神舟放飞的不只是载人飞船，而是这个民族几千年来的飞天梦想。如今，月球上的玉兔月球车正在延续我们的下一个梦想。</p>
</li>
<li><p><a href="https://book.douban.com/subject/4238941/"><strong>新卖桔者言</strong></a>. 张五常</p>
</li>
<li><p><a href="https://book.douban.com/subject/5252677/"><strong>幸福了吗？</strong></a>. 白岩松</p>
</li>
<li><p><a href="https://book.douban.com/subject/1016003/"><strong>鲁滨逊漂流记</strong></a>. 笛福</p>
</li>
<li><p><a href="https://book.douban.com/subject/3815131/"><strong>一九八四</strong></a>. 乔治 · 奥威尔</p>
</li>
<li><p><a href="https://book.douban.com/subject/26371139/"><strong>动物庄园</strong></a>. 乔治 · 奥威尔</p>
</li>
<li><p><a href="https://book.douban.com/subject/1050339/"><strong>文化苦旅</strong></a>. 余秋雨</p>
</li>
<li><p><a href="https://book.douban.com/subject/20427187/"><strong>看见</strong></a>. 柴静</p>
</li>
<li><p><a href="https://book.douban.com/subject/1008145/"><strong>围城</strong></a>. 钱钟书</p>
</li>
<li><p><a href="https://book.douban.com/subject/1258378/"><strong>他改变了中国</strong></a>. 罗伯特 · 劳伦斯 · 库恩</p>
</li>
</ul></div><div class="tab-pane" id="share-2"><p>一些自己看过的优秀纪录片，以 CCTV 与 BBC 拍摄的纪录片为主，大多是人文历史或者社会纪实类型。自然地理方面的纪录片很少，主要是因为个人对这个题材的纪录片不太感兴趣。</p>
<h3 id="国产纪录片"><a href="#国产纪录片" class="headerlink" title="国产纪录片"></a>国产纪录片</h3><ul>
<li><p><strong>超级工程</strong> <font color="#bbb">CCTV 科技</font><br>第三季模仿了 PBS 的 America Revealed，之前看时候就在想中国什么时候也这样拍一部就完美了，然后央视就满足了我的愿望；此外饱受争议的纪录片《辉煌中国》与电影《厉害了我的国》很多素材其实来自超级工程相关纪录片，所以剪辑拼凑痕迹明显，制作比较粗糙，看辉煌中国还不如看超级工程。</p>
</li>
<li><p><strong>舌尖上的中国</strong> <font color="#bbb">CCTV 社会文化</font><br>陈晓卿的美食纪录片，讲述美食遍布中华大地，不过《舌尖上的中国》只推荐第一、二季，第三季水平下滑严重，不值得推荐。</p>
</li>
<li><p><strong>风味人间</strong> <font color="#bbb">腾讯视频 社会文化</font><br>陈晓卿的美食纪录片，不同于之前的美食纪录片，本片不只是局限在中国，一大亮点就是中外对于同一种食材或者不同风格食材处理方式的对比。</p>
</li>
<li><p><strong>过台湾</strong> <font color="#bbb">CCTV 历史</font><br>讲述台湾1945年光复之前400年的历史变迁，史料翔实覆盖广泛，配乐也超级有魔性；如果需要了解台湾光复前后的历史还可以看《台湾·1945》。</p>
</li>
<li><p><strong>我在故宫修文物</strong> <font color="#bbb">CCTV 文化</font><br>网红纪录片不解释</p>
</li>
<li><p><strong>再说长江</strong> <font color="#bbb">CCTV 社会纪实</font><br>长江流域人文风土纪录片，呼应八十年代爆火纪录片《话说长江》。话说长江算是和同年代央视纪录片《河殇》走了不同的路线，该片在讲述人文风土同时也某种程度上提升了当时民众的民族自豪感与自信心</p>
</li>
<li><p><strong>大国崛起</strong> <font color="#bbb">CCTV 历史</font><br>讲述西方历史上各强国崛起历史，本质是为了探究中国复兴之路，这个目的从纪录片最后一集就可以看出来了。此外，该纪录片的旁白稿子很棒，单独拿出来都是一份很好的学习材料。</p>
</li>
<li><p><strong>东方卫视医警系列</strong> <font color="#bbb">东方卫视 社会纪实</font><br>有《巡逻现场实录》、《急诊室故事》、《生命时速·紧急救护120》等多部，跟踪拍摄上海市的警察巡逻、院前急救、急诊室抢救等故事，既是记录社会生活的点点滴滴，也展现了管理上海市这样一个超大型城市所需要的精细度。</p>
</li>
<li><p><strong>我的铁路，我的故事</strong> <font color="#bbb">CCTV 社会纪实</font><br>中国援建蒙巴萨-内罗毕铁路的故事，该片有英文版 My Railway, My Story；该片中有很多有趣的援非工程故事，以小见大讲述了中国援非工程的实施过程。</p>
</li>
</ul>
<h3 id="日本纪录片"><a href="#日本纪录片" class="headerlink" title="日本纪录片"></a>日本纪录片</h3><ul>
<li><p><strong>纪实72小时 ドキュメント72時間</strong> <font color="#bbb">NHK 社会纪实</font><br>用72小时不间断地拍摄记录日本的寻常生活，有欢笑有悲伤，每集看完总有一种依依不舍之情。目前，东方卫视也引进了版权，拍摄了中国版的《纪实72小时》。</p>
</li>
<li><p><strong>可以跟着去你家吗？ 家、ついて行ってイイですか?</strong> <font color="#bbb">东京电视台 社会纪实</font><br>节目专门访问赶不上末班电车的陌生人，以支付计程车费来换取跟随到他们家访问的机会，进而领略纪录人生百态。</p>
</li>
</ul>
<h3 id="欧美纪录片"><a href="#欧美纪录片" class="headerlink" title="欧美纪录片"></a>欧美纪录片</h3><ul>
<li><p><strong>透视美国 America Revealed</strong> <font color="#bbb">PBS 社会纪实</font><br>用俯视的视角，从食品、交通、能源、制造四个方面全景展示了美国各个产业概况和不为人知的细节。最开始看的时候对美国的产业状况叹为观止，后来看了央视《超级工程》第三季发现我们用同样的视角也可以展现一个有活力、有创造力的中国。</p>
</li>
<li><p><strong>企鹅群里有特务 Penguins: Spy in the Huddle</strong> <font color="#bbb">BBC 自然地理</font><br>自然地理纪录片里难得一部很喜欢的片子，光看着各种企鹅卖萌的样子就很疗愈了，颜值果然很重要。</p>
</li>
<li><p><strong>空中浩劫 Mayday</strong> <font color="#bbb">Cineflix 科技与社会</font><br>各种惊心动魄，各种细致入微，细致的调查背后是对生命的尊重。</p>
</li>
<li><p><strong>我们的孩子足够坚强吗？中式学校 Are Our Kids Tough Enough? Chinese School</strong> <font color="#bbb">BBC 教育</font><br>让5名中国老师在英国南部汉普郡的一所中学实施 4 周中国式教学试验的故事。说实话，这样短期的社会实验没什么大的研究意义吧，一些评论把所谓的对比看得太严重了反而感觉不会，纯当作真人秀综艺节目看倒是很有趣的。</p>
</li>
</ul></div></div></div>]]></content>
  </entry>
  <entry>
    <title>标签们</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<h1 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h1>]]></content>
  </entry>
</search>
